
#ifndef __pragma_USE_EXAMPLE_H__
#define __pragma_USE_EXAMPLE_H__



/*
	目录：
	（0） 前言
	（1） #pragma message能够在编译信息输出窗口中输出相应的信息
	（2） #pragma code_seg能够设置程序中函数代码存放的代码段,开发驱动程序的时会用到
	（3） #pragma  once若用在头文件的最开始处就能够保证头文件被编译一次
	（4） #pragma  hdrstop表示预编译头文件到此为止
	（5） #pragma  resource "*.dfm"表示把*.dfm文件中的资源加入工程
	（6） #pragma warning允许有选择性的修改编译器的警告消息的行为
	（7） #pragma comment将一个注释记录放入一个对象文件或可执行文件中
	（8） #pragma data_seg建立一个新的数据段并定义共享数据
			应用1：在DLL中定义一个共享的，有名字的数据段
			应用2： data_seg控制应用程序的启动次数
	（9）#pragma pack(4) 字节对齐
*/


// 0	前言
/*
#Pragma 指令的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。
#pragma 指令对每个编译器给出了一个方法,在保持与C和C++语言完全兼容的情况下,给出主机或操作系统专有的特征。
依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。   
其格式一般为:   #Pragma   Para   
其中Para为参数，下面来看一些常用的参数。  
*/





// ------------------------------------------------------------------------------------------------------------------
//						1	#pragma message	
// ------------------------------------------------------------------------------------------------------------------
/*	
#Pragma message参数能够在编译信息输出窗口中输出相应的信息

这对于源代码信息的控制是非常重要的。其使用方法为： Pragma   message(“消息文本”)    
当我们在程序中定义了许多宏来控制源代码版本的时候，
我们自己有可能都会忘记有没有正确的设置这些宏，
此时我们可以用这条指令在编译的时候就进行检查。
假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法。   
*/

#define _X86
#ifdef   _X86   
#pragma message("_X86 macro activated!")		// 这里打印出的 字符在 “生成” 那个窗口。
#endif   

// 若定义了_X86，程序编译时就会在显示“_X86 macro activated!”。

// “生成” 窗口。
/*	
	1>------ 已启动生成: 项目: #pragmaUseExample, 配置: Debug Win32 ------
	1>  main.cpp
	1>  _X86 macro activated!
	1>  #pragmaUseExample.vcxproj -> D:\回退位置-VS存储sdf和ipch的临时文件【需要定期清理】\输出目录\#pragmaUseExample\Debug\#pragmaUseExample.exe
	========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========
*/





// ------------------------------------------------------------------------------------------------------------------
//						3	#pragma once 
// ------------------------------------------------------------------------------------------------------------------
/*
(比较常用)只要在头文件的最开始加入这条指令就能够头文件被编译一次。

一般在整个工程中我们只要包含头文件一次就够了，若多个.c/.cpp 文件中都要包含同一个头文件，
比如 Windows.h，那很多声明等等岂不是有两次了？解决这个问题的传统的方法是在头文件开始出用 #define 定义一个宏，比如 Windows.h 中:   
#ifndef   _WINDOWS_   
#define   _WINDOWS_   
#endif
这样就可以避免被包含多次。但是这样的后果是代码的可读性较差 (个人观点)，VC给我们提供了另外一个途径，那就是在文件的前面加上:   
*/
#pragma once



// ------------------------------------------------------------------------------------------------------------------
//						4，5，感觉 不是很重要，现在用不到，以后学
// ------------------------------------------------------------------------------------------------------------------


// ------------------------------------------------------------------------------------------------------------------
//						6	#pragma warning
// ------------------------------------------------------------------------------------------------------------------

#pragma warning (disable:4507  34; once:4385; error:164)  //等价于 下面3个

#pragma warning (disable:4507  34）  //不显示4507和30号警告信息

#pragma warning (once:4385）  //4358号警告信息仅报告一次

#pragma warning (error:164） //把164号警告信息作为一种错误

// ------------------------------------------------------------------------------------------------------------------
//						7	#pragma comment
// ------------------------------------------------------------------------------------------------------------------
/* 
该指令的格式为：
#pragma comment( "comment-type" [, commentstring] )
comment-type(注释类型):可以指定为五种预定义的标识符的其中一种，五种预定义的标识符为:
*/

//compiler:将编译器的版本号和名称放入目标文件中,本条注释记录将被编译器忽略，如果你为该记录类型提供了commentstring参数,编译器将会产生一个警告
#pragma comment(compiler)

#if 0
/* 
exestr: 链接时，将commentstring参数放入到可执行文件中,当操作系统加载可执行文件的时候,
该参数字符串不会被加载到内存中.但是,该字符串可被dumpbin之类的程序查找出并打印出来,
你可以用这个标识符将版本号码之类的信息嵌入到可执行文件中!
*/
#pragma comment(exestr,"/SECTION:flag_data,RWS")


#pragma comment(lib,   "WSock32.lib")

// 常用的有lib标识符，比如，glut.h文件里有：
#pragma comment (lib, "winmm.lib")    
#pragma comment (lib, "opengl32.lib") 
#pragma comment (lib, "glu32.lib")    
#pragma comment (lib, "glut32.lib")   
// 这样的好处是，用户只要包含了	#include<gl/glut.h> ，就不用亲手再去属性（或者是settings）里设置了。


/* 
linker:将一个链接选项放入目标文件中,你可以使用这个指令来代替由命令行传入的或者在开发环境中设置的链接选项,
你可以指定/include选项来强制包含某个对象,例如:
*/
#pragma comment(linker,"/SECTION:flag_data,RWS")
/*
这样的，也免去了别人使用时自己设置连接器的麻烦。

你可以在程序中设置下列链接选项
/DEFAULTLIB
/EXPORT
/INCLUDE
/MERGE
/SECTION
这些选项在这里就不一一说明了,详细信息请看msdn!
*/
#endif

// user:将一般的注释信息放入目标文件中commentstring参数包含注释的文本信息,这个注释记录将被链接器忽略，例如:
#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__ )


// ------------------------------------------------------------------------------------------------------------------
//						8	#pragma data_seg
// ------------------------------------------------------------------------------------------------------------------
/*
建立一个新的数据段并定义共享数据

	格式为：
#pragma data_seg （"shareddata"）
	HWND sharedwnd=NULL;//共享数据
#pragma data_seg()
*/

/*
应用1：在DLL中定义一个共享的，有名字的数据段。

注意：	a、这个数据段中的全局变量能够被多个进程共享。否则多个进程之间无法共享DLL中的全局变量。
		b、共享数据必须初始化，否则微软编译器会把没有初始化的数据放到.BSS段中，从而导致多个进程之间的共享行为失败。

		具体的代码 示例 可以看 多进程之间通信那块的代码。
*/

/*
应用2： data_seg控制应用程序的启动次数
	有的时候我们可能想让一个应用程序只启动一次，就像单件模式(singleton)一样，实现的方法可能有多种，这里说说用#pragma data_seg来实现的方法，很是简洁便利。应用程序的入口文件前面加上：
*/
#pragma data_seg("flag_data")
	int app_count = 0;
#pragma data_seg()
#pragma comment(linker,"/SECTION:flag_data,RWS")

// #pragma comment(linker, "/SECTION:Name,RWS")设置名为Name的数据段属性。
// /SECTION就表示为这是一个数据区间，R——Read读，W——Write写，S——Share共享。

/*
然后程序启动的地方加上
	if(app_count>0)    // 如果计数大于0，则退出应用程序。
	{
		//MessageBox(NULL, "已经启动一个应用程序", "Warning", MB_OK);
		//printf("no%d application", app_count);
		return FALSE;
	}
	app_count++;
*/

/*	同理在推出： 应用退出前，最后一步，要 app_count--; 否则 比如我想最多启动2个实例。你先启动1个实例，app_count = 1了。
	再启动第2个应用程序，app_count = 2. 然后我随便关掉 其中一个应用程序，app_count都还是2.无法再打开新的 应用程序。

	当然如果只是想保证单例模式的话，就不需要 退出前 减1了。
*/



// ------------------------------------------------------------------------------------------------------------------
//						9	#pragma pack
// ------------------------------------------------------------------------------------------------------------------

#pragma pack(4)

// 参考文章：	http://blog.csdn.net/jamesf1982/article/details/4375719

// VS IDE 提供的功能。程序里面用到了这个，可能不是很 具有 移植性。

// ------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------











#endif // __pragma_USE_EXAMPLE_H__