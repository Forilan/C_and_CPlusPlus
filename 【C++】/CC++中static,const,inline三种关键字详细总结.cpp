

// CC++中static,const,inline三种关键字详细总结
/*
	参考文章：
	http://www.jb51.net/article/41629.htm
*/

// __________________________ 1-关于static  __________________________
/*
	static 是C++中很常用的修饰符，它被用来控制变量的存储方式和可见性，
	下面将从 static 修饰符的产生原因、作用谈起，全面分析static 修饰符的实质。

	static 的两大作用:
*/ 

// 一、控制存储方式 
/*
	static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间。

	引出原因：
	函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，
	这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？
	最容易想到的方法是定义一个全局的变量，但定义为一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围
	（使得在此函数中定义的变量，不仅仅受此函数控制）。
	
	解决方案：
	因此C++ 中引入了static，用它来修饰变量，它能够指示编译器将此变量在程序的静态存储区分配空间保存，这样即实现了目的，
	又使得此变量的存取范围不变。	

*/

// 二、控制可见性与连接类型  
/*
	static还有一个作用，它会把变量的可见范围限制在编译单元中，使它成为一个内部连接，这时，它的反义词为”extern”。

	static作用分析总结：
	static总是使得变量或对象的存储形式变成静态存储，连接方式变成内部连接，
	对于局部变量（已经是内部连接了），它仅改变其存储方式；
	对于全局变量（已经是静态存储了），它仅改变其连接类型。

	类中的static成员
	出现原因及作用：
	1、需要在一个类的各个对象间交互，即需要一个数据对象为整个类而非某个对象服务。
	2、同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。
	类的static成员满足了上述的要求，因为它具有如下特征：有独立的存储区，属于整个类。
	
	注意：
	1、对于静态的数据成员，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，
	注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

	2、类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。

*/


// __________________________ 2-关于const  __________________________
/*
	const 是C++中常用的类型修饰符，但我在工作中发现，许多人使用它仅仅是想当然尔，这样,有时也会用对，但在某些微妙的场合，可就没那么幸运了，
	究其实质原由，大多因为没有搞清本源。这里将对const进行辨析。溯其本源，究其实质，希望能对大家理解const有所帮助，
	根据思维的承接关系，分为如下几个部分进行阐述。
*/

//	C++中为什么会引入const
/*	
	C++的提出者当初是基于什么样的目的引入（或者说保留）const关键字呢？，这是一个有趣又有益的话题，对理解const很有帮助。
	1．大家知道，C++有一个类型严格的编译系统，这使得C++程序的错误在编译阶段即可发现许多，从而使得出错率大为减少，
		因此，也成为了C++与C相比，有着突出优点的一个方面。
	2． C中很常见的预处理指令 #define VariableName VariableValue 可以很方便地进行值替代，

		这种值替代至少在三个方面优点突出： 
			一是避免了意义模糊的数字出现，使得程序语义流畅清晰，如下例： 
				#define USER_NUM_MAX 107 这样就避免了直接使用107带来的困惑。
			二是可以很方便地进行参数的调整与修改，如上例，当人数由107变为201时，进改动此处即可；

			三是提高了程序的执行效率，由于使用了预编译器进行值替代，并不需要为这些常量分配存储空间，所以执行的效率较高。

	鉴于以上的优点，这种预定义指令的使用在程序中随处可见。

	3．说到这里，大家可能会迷惑上述的1点、2点与const有什么关系呢?,好，请接着向下看来：
	预处理语句虽然有以上的许多优点，但它有个比较致命的缺点，即，预处理语句仅仅只是简单值替代，缺乏类型的检测机制。
	这样预处理语句就不能享受C++严格类型检查的好处，从而可能成为引发一系列错误的隐患。
	
	4．好了，第一阶段结论出来了：
	结论： const 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点。
	现在它的形式变成了：
	const DataType VariableName = VariableValue ;
*/

//	为什么const能很好地取代预定义语句？
/*	
	const 到底有什么大神通，使它可以振臂一挥取代预定义语句呢？
		首先，以const 修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。

		第二，很明显，它也同样可以避免意义模糊的数字出现，同样可以很方便地进行参数的调整和修改。

		第三，C++的编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，
		没有了存储与读内存的操作，使得它的效率也很高，同时，这也是它取代预定义语句的重要基础。

		这里，我要提一下，为什么说这一点是也是它能取代预定义语句的基础，这是因为，编译器不会去读存储的内容，
		如果编译器为const分配了存储空间，它就不能够成为一个编译期间的常量了。
	
		最后，const定义也像一个普通的变量定义一样，它会由编译器对它进行类型的检测，消除了预定义语句的隐患。		
*/


// 	const 使用情况分类详析 	
/*
	1.const 用于指针的两种情况分析
	　int const *A; 　file://A可变，*A不可变 
	　int *const A; 　file://A不可变，*A可变
	分析：const 是一个左结合的类型修饰符，它与其左侧的类型修饰符和为一个类型修饰符，所以，int const 限定 *A,不限定A。int *const 限定A,不限定*A。
	2.const 限定函数的传递值参数
	　void Fun(const int Var); 
	分析：上述写法限定参数在函数体中不可被改变。由值传递的特点可知，Var在函数体中的改变不会影响到函数外部。所以，此限定与函数的使用者无关，仅与函数的编写者有关。
	结论：最好在函数的内部进行限定，对外部调用者屏蔽，以免引起困惑。如可改写如下： 
*/

/*
	3. const 限定函数的值型返回值 
	const int Fun1(); 
	const MyClass Fun2();
	分析:上述写法限定函数的返回值不可被更新，当函数返回内部的类型时（如Fun1），已经是一个数值，当然不可被赋值更新，
	所以，此时const无意义，最好去掉，以免困惑。当函数返回自定义的类型时（如Fun2），这个类型仍然包含可以被赋值的变量成员，所以，此时有意义。
	
	4. 传递与返回地址
	此种情况最为常见，由地址变量的特点可知，适当使用const，意义昭然。
	
	5. const 限定类的成员函数
*/

/*
	注意：采用此种const 后置的形式是一种规定，亦为了不引起混淆。在此函数的声明中和定义中均要使用const,因为const已经成为类型信息的一部分。
	
	获得能力：可以操作常量对象。
	
	失去能力：不能修改类的数据成员，不能在函数中调用其他不是const的函数。
*/	


// __________________________ 3-关于inline  __________________________	
/*
	在上面谈了const后，下面再来谈一下inline这个关键字，之所以把inline放在这个位置,是因为inline这个关键字的引入原因和const十分相似，
	下面分为如下几个部分进行阐述。
*/

// 	C++中引入inline关键字的原因: 
/*
	inline 关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式形式的宏定义。
*/

// 表达式形式的宏定义一例：
#define ExpressionName(Var1,Var2) (Var1+Var2)*(Var1-Var2)	

// 为什么要取代这种形式呢，且听我道来：
/*
	1．首先谈一下在C中使用这种形式宏定义的原因，C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，
	没有了参数压栈，代码生成等一系列的操作,因此，效率很高，这是它在C中被使用的一个主要原因。
	
	2．这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，
	也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，
	这样，它的使用就存在着一系列的隐患和局限性。
	
	3．在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，
	你就不可能使用这种宏定义来实现(因为无法将this指针放在合适的位置)。
	
	4． inline 推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了它的缺点，同时又很好地继承了它的优点。
	为什么inline能很好地取代表达式形式的预定义呢？
*/	

/*	对应于上面的1-3点，阐述如下：
	1． inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。
	
	2．很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。
	然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
	
	3． inline 可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。
*/

/*	在何时使用inline函数

	首先，你可以使用inline函数完全取代表达式形式的宏定义。
	另外要注意，内联函数一般只会用在函数内容非常简单的时候，这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，
	代码膨胀带来的恶果很可能会大于效率的提高带来的益处。内联函数最重要的使用地方是用于类的存取函数。
*/

/*	
	如何使用类的inline函数
	简单提一下inline 的使用吧：
*/

/*
1.在类中定义这种函数
代码如下:
*/
class ClassName{ 
..... 
.... 
GetWidth(){return m_lPicWidth;}; // 如果在类中直接定义，可以不使用inline修饰 
.... 
.... 
};
/*
2.在类中声明，在类外定义: 
代码如下:
*/
class ClassName{ 
..... 
.... 
GetWidth(); // 如果在类中直接定义，可以不使用inline修饰 
.... 
.... 
}; 
inline ClassName::GetWidth()
{
return m_lPicWidth;
}
/*
在本文中，谈了一种特殊的函数，类的inline函数，它的源起和特点在某种说法上与const很类似，可以与const搭配起来看。
*/