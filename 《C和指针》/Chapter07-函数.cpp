

//#include "Chapter07.h"


// 7.1 函数定义
/*
	有2种方法定义：
*/

// 非常老式的声明
int * 
find_int(key,array,array_len)
int key;
int array[];
int array_len;
{

}


// 不提倡上面的方法,上面之所以保留，是为了让较老的程序无需修改便可以通过编译。
int *
find_int(int key,int array[],int array_len)
{
	int i;
	for( i = 0; i < array_len; i += 1)
	{
		if (array[i] == key)
		{
			return &array[i];
		}
	}
}



// 7.2 函数声明
/*
	使用头文件。这个技巧比前一种方法更好。
	1.现在函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件，较之在该函数每次调用前单独书写一份函数原型要容易得多。
	2.现在函数原型只书写一次，这样就不会出现多份原型的拷贝之间的不匹配现象。
	3.如果函数的定义进行了修改，我们只需要修改原型，并重新编译所有包含了该原型的源文件即可。
	4.如果函数的原型同时也被#include指令包含到定义函数的文件中，编译器就可以确认函数原型与函数定义的匹配。
*/

// func.h
int * func( int * value, int len );		

// func.c
#include "func.h"	
int * func( int * value, int len );
{

}

// 7.3 函数的参数
/*
	C函数的所有参数 均以“传值调用”方式进行传递的，这意味着函数将获得参数值的一份拷贝。
	这样，函数可以放心修改这个拷贝值,而不必担心会修改调用程序实际传递给它的参数。

	C的规则很简单：所有参数都是传值调用。但是如果被传递的参数是一个数组名，并且在函数中使用下标引用该数组的参数，
	那么函数中对数组元素进行修改实际上修改的是调用程序中的数组元素。函数将访问调用程序的数组元素，数组并不会复制。
	这个行为被称为：“地址调用”。


	数组参数的这种行为似乎与传值调用规则相逆，但是，此处其实并无矛盾之处——————数组名的值实际上是一个指针，
	传递给函数的就是这个指针的一份拷贝。下标引用实际上是间接访问的另一种形式，它可以对指针执行间接访问操作，
	访问指针指向的内存位置。参数（指针）实际上是一份拷贝，但在这份拷贝上执行间接访问操作所访问的是原先的数组。

	
*/