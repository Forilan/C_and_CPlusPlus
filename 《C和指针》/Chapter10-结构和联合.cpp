

//#include "Chapter10.h"


// 第10章 结构和联合
/*
	数据经常以成组的形式存在。如果这些值能够存储在一起，访问起来会简单一些。
	但是，如果这些值的类型不同，它们无法存储于同一个数组中。
	在C中，使用结构可以把不同类型的值存储在一起。
*/

// __________________________10.1 结构基础知识__________________________
/*
	聚合数据类型 能够同时存储超过一个的单独数据。C提供了两种类型的聚合数据类型，数组和结构。
	数组是相同类型的元素的集合，它的每个元素是通过下标引用或指针间接访问来选择的。
	结构也是一些值的集合，这些值称为它的成员，但一个结构的各个成员可能具有不同的类型。

	结构变量属于标量类型，所以 你可以像对待其他标量类型那样执行
*/


// 10.1.1 结构声明
/*
	在声明结构时，必须列出它包含的所有成员。这个列表包括每个成员的类型和名字。
*/


struct SIMPLE{
	int 	a;
	char  	b;
	float	c;
};	


struct SIMPLE x;
struct SIMPLE y[20], *z;

// 这样x,y,z都是同一种类型的结构变量。这样就可以进行下面这样的赋值了。
z = &x;


// 或者声明结构时可以使用 typedef 创建一种新的类型，如下例子：
typedef struct{
	int 	a;
	char  	b;
	float	c;
} Simple;	

// 现在 Simple 是个类型名而不是结构标签，所以后续的声明可能像下面这个样子：
Simple x;
Simple y[20], *z;


// 10.1.2 结构成员
/*	可以在一个结构外部声明的任何变量都可以作为结构的成员。
	尤其是，结构成员可以是标量，数组，指针甚至是其他结构。
 */
struct COMPLEX {
	float 	f;
	int 	a[20];
	long 	*lp;
	struct 	SIMPLE s;
	struct 	SIMPLE sa[10];
	struct 	SIMPLE *sp;
};

// 10.1.3 结构成员的直接访问
/*
	结构变量的成员是通过点操作符（.）访问的。点操作符接受两个操作数，左操作数就是结构变量的名字，
	右操作数就是需要访问的成员的名字。这个表达式的结果就是指定的成员。	
*/


// 10.1.4 结构成员的间接访问
/*
	如果你拥有一个指向结构的指针，你该如何访问这个结构的成员呢？首先就是对指针执行间接访问操作，
	这使你获得这个结构。然后你使用点操作符来访问它的成员。如下：
*/

(*cp).f;		// 对指针执行间接访问将访问结构，然后点操作符访问一个成员。

/*
	由于这个概念有点惹人厌，所以C语言提供了一个更为方便的操作符来完成这项工作  ->  操作符（也称箭头操作符）
	箭头操作符 接受两个操作数，但左操作数 必须是一个指向结构的指针。
*/ 
cp->f;
cp->a;
cp->s;


// 10.1.5 结构的自引用
/*
	在一个结构内部包含一个类型为该结构本身的成员是否合法呢？
*/

struct SELF_REFL
{
	int 	a;
	struct 	SELF_REFL b;
	int 	c;
};
/*
	这种类型的 自引用 是非法的，因为成员b是另一个完整的结构，其内部还将包含它自己的成员b。
	这第2个成员又是另一个完整的结构，它还将包括它自己的成员b.这样重复下去永无止境。
	但是下面这个声明是合法的。
*/ 
struct SELF_REFL
{
	int 	a;
	struct 	SELF_REFL *b;
	int 	c;
};
/*
	这个声明和前面 那个声明的区别在于b现在是一个指针而不是结构。
	编译器在结构的长度确定之前就已经知道指针的长度，所以这种类型的自引用是合法的。
	这个指针事实上所指向的是同一种类型的不同结构。更加高级的数据结构，如链表和树，都是用这种技巧实现的。
	每个结构指向链表的下一个元素或树的下一个分枝。
*/ 


// 警惕下面这个陷阱：
typedef struct {
	int 	a;
	struct 	SELF_REFL *b;
	int 	c;
}SELF_REFL;	
/*
	这个声明的目的是为这个结构创建类型名 SELF_REFL，但是，它失败了。类型名直到声明的末尾才定义，
	所以在结构声明的内部它尚未定义。
	解决方案是定义一个结构标签来声明b,如下所示：
*/ 
typedef struct SELF_REFL_TAG{
	int 	a;
	struct 	SELF_REFL_TAG *b;
	int 	c;
}SELF_REFL;	


// 10.1.6 不完整的声明
/*
	偶尔，你必须声明一些相互之间存在依赖的结构。也就是说，其中一个结构包含了另一个结构的一个或多个成员。
	和自引用结构一样，至少有一个结构必须在另一个结构内部以指针的形式存在。
	问题在于声明部分：如果每个结构都引用了其他结构的标签，哪个结构应该首先声明呢？

	这个问题的解决方案是使用不完整声明，它声明一个作为结构标签的标识符。然后，
	我们可以把这个标签用在不需要知道这个结构的长度的声明中，如果声明指向这个结构的指针。
	接下来的声明把这个标签与成员列表联系在一起。

	考虑下面这个列子，两个不同类型的结构内部都有一个指向另一个结构的指针。
*/ 

struct B;

struct A
{
	struct B  *partner;
};

struct B
{
	struct A  *partner;
};
/*
	在A的成员列表中需要标签B的不完整的声明。一旦A被声明之后，B的成员列表也可以被声明。
*/


// 10.1.7 结构的初始化
/*
	结构的初始化方式和数组的初始化方式很相似。一个位于一对花括号内部，由逗号分隔的初始值列表可用于结构各个成员的初始化。
	这些值根据结构成员列表的顺序写出。如果初始列表的值不够，剩余的结构成员将使用缺省值进行初始化。
	
	下面有一个例子：
*/

struct INIT_EX{
	int 	a;
	short 	b[10];
	Simple  c;
} x = {
	10,
	{1,2,3,4,5},
	{25,'x',1.9}
};	


// __________________________10.2 结构,指针和成员__________________________
/*
	直接通过指针访问结构和它们的成员的操作符是相当简单的，
	但是它们应用于复杂的情形时就有可能引起混淆。

	下面有一个例子：
*/
typedef struct 
{
	int 	a;
	short 	b[2];
}Ex2;

typedef struct EX{
	int 	a;
	char 	b[3];
	Ex2 	c;
	struct 	EX 	*d;
}Ex;

// 第1个例子 将使用这些声明：

Ex  x = { 10, "Hi", { 5,{-1,25}}, 0};
Ex 	*px = &x;

// 10.2.1 访问指针
// 没看懂 这里 在讲些什么。

// 10.2.2 访问结构
/*
	我们可以使用*操作符 对指针执行间接访问。表达式*px的右值是px所指向的整个结构。
*/

// 10.2.3 访问结构成员
int *pi;
/*	能不能让pi指向整型成员a?如果pi的值和px相同，那么表达式*pi的结果将是成员a.	
 */ 
pi = px; 
// 上面的表达式是非法的，因为它们的类型不匹配。使用强制类型转换就能奏效：
pi = (int *)px;
/*
	但是这种方法是很危险的，因为它避开了编译器的类型检查。
	正确的表达式更为简单————使用&操作符取得一个指向px->a的指针：
*/ 
pi = & px->a;


// 10.2.4 访问嵌套的结构
px->c;
px->c.a;

*px->c.b;		// 等价于下面的表达式
*((px->c).b);
/*
	px->c 返回的是一个结构，而不是一个指针。所以用.b
	px->c.b 返回的是一个 数组名。
	*px->c.b 对一个数组名 进行 * 操作，得到的是数组中第1个元素。
	所以表达式的最终结果是数组的第1个元素。
*/

// 10.2.5 访问指针成员
/*
	表达式 px->d 的结果正如你所料————它的右值是0，它的左值是它本身的内存位置。
	*px->d 更为有趣。这里间接访问操作符作用于成员d所存储的指针值。
	让我们创建另一个结构，并把 x.d 设置为指向它。
*/
Ex 		y;
x.d = &y;

/*
	现在我们可以对表达式 *px->d求值。成员d指向一个结构，
	所以对它执行间接访问操作的结果是整个结构。	
*/ 


// __________________________10.3 结构的存储分配__________________________
/*
	结构在内存中是如何实际存储的呢？前面例子的这张图似乎提示了结构内部包含了大量的未用空间。
	但这张图并不完全准确，编译器按照成员列表的顺序一个接一个地给每个成员分配内存。
	只有当存储成员时需要满足正确的边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。
	为了说明这点，考虑下面这个结构：	
*/ 
struct ALIGN{
	char a;
	int  b;
	char c;
};
/*
	如果某个机器的整型值长度为4个字节，并且它的起始存储位置必须能够被4整除，
	存储方式如图中所示：P227
*/
// a 0 0 0 b b b b c 0 0 0
// 一个结构占了12个字节。

/*
	系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐要求，
	因此所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置。
*/	

/* 可以在声明中 对结构的成员列表重新排列，让那些对边界要求最严格的成员首先出现，
	对边界要求最弱的成员最后出现。这种做法可以最大限度地减少因边界对齐而带来的空间损失。
 	例如：下面这个结构：
 */	
 struct ALIGN2{
	int  b;
	char a;
	char c;
};	
//  b b b b a c 0 0
// 这个结构只占了8个字节的空间，节省了33%。


/*
	有时，我们有充分的理由，决定不对结构的成员进行重排以减少因对齐带来的空间损失。
	例如，我们可能想把相关的结构成员存储在一起，提高程序的可维护性和可读性。
	但是，如果不存在这样的理由，结构的成员应该根据它们的边界需要进行重排，
	减少因边界对齐而造成的内存损失。

	当程序 将创建几百个甚至几千个结构时，减少内存浪费的要求就比程序的可读性更为紧迫。
	在这种情况下，在声明中增加注释可能避免可读性方面的损失。

	sizeof 操作符 能够得出一个结构的整体长度，包括因边界对齐而跳过的那些字节。
	如果你必须确定结构某个成员的实际位置，应该考虑边界对齐因素，可以使用offset宏。
*/

offsetof(type,member);	

offsetof(struct ALIGN, b);	


// __________________________10.4 作为函数参数的结构__________________________
/*
	结构变量是一个标量，它可以用于其他标量可以使用的任何场合。因此，把结构作为参数传递给一个函数是合法的，
	但这种做法往往并不适宜。
	下面的代码是一个例子。
*/

typedef struct {
	char 	product[PRODUCT_SIZE];
	int 	quantity;
	float 	unit_price;
	float 	total_amount;
}Transaction;

void print_receipt( Transaction trans )
{
	printf( "%d @ %.2f total %.2f\n ",trans.quantity,trans.unit_price,trans.total_amount);
}

// 如果 current_trans 是一个 Transaction 结构，我们可以像下面这样调用函数：
print_receipt( current_trans );

/*
	警告：这个方法能够产生正确的结果，但它的效率很低，因为C语言的参数传值调用方式要求把参数的一份拷贝传递给函数。
	如果这个结构占据32个字节的空间。要想把它作为参数进行传递，我们必须把32个字节复制到堆栈中，以后再丢弃。

	把前面那个函数和下面这个进行比较：
*/

void print_receipt( Transaction *trans )
{
	printf( "%d @ %.2f total %.2f\n ",trans->quantity,trans->unit_price,trans->total_amount);
}	

print_receipt( &current_trans );
/*
	这次传递给函数的是一个指向结构的指针。指针比整个结构要小得多，所以把它压到堆栈上效率提高很多。
	传递指针另外需要付出的代价是我们必须在函数中使用间接访问来访问结构的成员。
	结构越大，把指向它的指针传递给函数的效率就越高。
*/

/*
	在许多机器中，你可以把参数声明为寄存器变量，从而进一步提高指针传递方案的效率。

	向函数传递指针的缺陷在于函数现在可以对调用程序的结构变量进行修改。如果不希望如此，可以在函数中使用 const 关键字来防止这类修改。
	经过这两个修改之后，如下：
*/

void print_receipt( register Transaction const *trans );

/*
	让我们前进一个步骤，对结构体进行处理-赋值：
	显然还是 传递一个指针，要好很多。
*/

void compute_total_amount( register Transaction  *trans )
{
	trans->total_amount = trans->quantity * trans->unit_price;
}	

compute_total_amount( &current_trans );


/*
	现在，调用程序的结构的字段 total_amount 被直接修改，它并不需要把整个结构作为参数传递给函数，
	也不需要把整个修改过的结构作为返回值返回。这个版本比前两个版本效率高很多。
	另外，调用程序无需知道结构的内容，所以也提高了程序的模块化程度。
*/

/*
	什么时候你应该向函数传递一个结构而不是一个指向结构的指针呢？很少有这种情况。只有当一个结构特别的小（长度和指针相同或更小）时，
	结构传递方案的效率才不会输给指针传递方案。但对于绝大多数结构，传递指针显然效率更高。
	如果你希望函数修改结构的任何成员，也应该使用指针传递方案。
*/



// __________________________10.5 位段__________________________
/*
	关于结构，我们最后还必须提到它们实现位段（bit field）的能力。位段的声明和结构类似，但它的成员
	是一个或多个位的字段。这些不同长度的字段实际上存储于一个或多个整型变量中。

	位段的声明和任何普通的结构成员声明相同，但有两个例外。首先，位段成员必须声明为 int,signed int 或
	unsigned int 类型。其次，在成员名的后面是一个冒号和一个整数，这个整数指定该位段所占用的位的数目。
*/

/*
	注重可移植性的程序应该避免使用位段。由于下面这些与实现有关的依赖性，位段在不同的系统中可能有不同的结果。

	下面是一个位段声明的例子：
*/

struct CHAR{
	unsigned ch 	:	7;
	unsigned font 	:	6;
	unsigned size 	:	19;
};	
struct CHAR ch1;

/*
	这个例子说明了一个使用位段的好理由：它能够把长度为奇数的数据包装在一起，节省存储空间。

	另一个使用位段的理由是由于它们可以很方便地访问一个整型值的部分内容。

	使用位段只是基于方便的目的，任何可以用位段实现的任务都可以使用移位和屏蔽来实现。
*/

/*
	提示：
	在源代码中，用位段表示这个处理过程更为简单一些，但在目标代码中，这两种方法并不存在任何区别。
	无论是否使用位段，相同的移位和屏蔽操作都是必需的。位段提供的唯一优点是简化了源代码。
	这个优点必须与位段的移植性较弱这个缺点进行权衡。
*/

// __________________________10.6 联合__________________________
/*
	和结构相比，联合可以说是另一种动物了。联合的声明和结构类似，但它的行为方式却和结构不同。
	联合的所有成员引用的是内存中的相同位置。当你想在不同的时刻把不同的东西存储于同一个位置时，就可以使用联合。
*/

union {
	float 	f;
	int 	i;
}fi;

fi.f = 3.14159;
printf("%d\n",fi.i);

/* 首先把 π 的浮点表示形式存储于fi, 然后把这些相同的位当作一个整型值打印输出。
	注意这两个成员所用的位相同，仅有的区别在于每个成员的类型决定了这些位被如何解释。
	如果你想看看浮点数 是如何存储在一种特定的机器中但又对其他东西不感兴趣，联合就可能有所帮助。

	如果联合的各个成员具有不同的长度，联合的长度就是它最长成员的长度。
 */


// 10.6.1 变体记录
/*
	在一个成员长度不同的联合里，分配给联合的内存数量取决于它的最长成员的长度。这样，联合的长度总是足以容纳它最大的成员。
	如果这些成员的长度相差悬殊，当存储长度较短的成员时，浪费的空间是相当可观的。在这种情况下，
	更好的方法是在联合中存储指向不同成员的指针而不是直接存储成员本身。所有指针的长度都是相同的，这样就解决了内存浪费的问题。
*/

// 10.6.2 联合的初始化
/*
	联合变量可以被初始化，但这个初始值必须是联合第1个成员的类型，而且它必须位于一对花括号里面。
*/
union{
	int 	a;
	float	b;
	char 	c[4];
}x={5};
// 把x.a初始化为5


// __________________________10.7 总结__________________________
/*
*/



// P232/469
