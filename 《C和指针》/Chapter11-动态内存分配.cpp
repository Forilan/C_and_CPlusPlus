

//#include "Chapter11.h"


// 第11章 动态内存分配
/*
	数组的元素存储于内存中连续的位置上。当一个数组被声明时，它所需要的内存在编译时就被分配。
	但是，你也可以使用动态内存分配在运行时为它分配内存。
*/


// __________________________11.1为什么使用动态内存分配__________________________



// __________________________11.2malloc和free__________________________
/*
	C函数库提供了两个函数，malloc 和 free ,分别用于执行动态内存分配和释放。这些函数维护一个可用内存池。
	当一个程序另外需要一些内存时，它就调用malloc函数，malloc从内存池中提取一块合适的内存，
	并向该程序返回一个指向这块内存的指针。这块内存此时并没有以任何方式进行初始化。

	如果对这块内存进行初始化非常重要，你要么自己动手对它进行初始化，要么使用 calloc函数。
	当一块以前分配的内存不再使用时，程序调用free函数把它归还给内存池供以后之需。
	这两个函数的原型如下所示，它们都在头文件stdlib.h中声明。
*/ 
void *malloc(size_t size);
void free(void *pointer);

/*  malloc 的参数就是需要分配的内存字节数。如果内存池中的可用内存可以满足这个需求，
	malloc就返回一个指向被分配的内存块起始位置的指针。
	
	malloc 所分配的是一块连续的内存。并不会分开位于两块或多块不同的内存。

	如果内存池是空的，或者它的可用内存无法满足你的请求，会发生什么情况呢？在这种情况下，
	malloc 函数向操作系统请求，要求得到更多的内存，并在这块新内存上执行分配任务。
	如果操作系统无法向malloc提供更多的内存，malloc就返回一个NULL指针。

	因此对每个从malloc返回的指针进行检查，确保它并非NULL是非常重要的。

	free的参数必须要么是NULL，要么是一个先前从 malloc,calloc或realloc返回的值。
	向free传递一个NULL参数不会产生任何效果。

	malloc又是如何知道你所请求的内存需要存储的是整数，浮点值，结构还是数组呢？
	它并不知道——————malloc 返回一个类型为 void* 的指针，正是源于这个原因。
	标准表示一个 void* 类型的指针可以转换为其他任何类型的指针。

	但是，有些编译器，尤其是那些老式的编译器，可能要求你在转换时使用强制类型转换。

	对于要求边界对齐的机器，malloc所返回的内存的起始位置将始终满足对边界对齐要求最严格的类型的要求。
 */	

// __________________________11.3calloc和realloc__________________________

/* 另外还有两个内存分配函数，calloc和realloc 它们的原型如下所示： */

void *calloc(size_t num_elements,
			 size_t element_size )；
void *realloc(void *ptr,size_t new_size);			// 这里原书 居然有个小BUG，

/* calloc 也用于分配内存。 malloc 和 calloc 之间的主要区别是后者在返回指向内存的指针之前把它初始化为0.
	这个初始化常常能带来方便，但如果你的程序只是想把一些值存储到数组中，那么这个初始化过程纯属浪费时间。
	另一个区别是 它们请求内存数量的方式不同。 calloc 的参数包括所需元素的数量和每个元素的字节数。
	根据这些值，它能够计算出总共需要分配的内存。
 */


/* realloc 函数用于修改一个原先已经分配的内存块的大小。使用这个函数，你可以使一块内存扩大或缩小。
如果它用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，
新内存并未以任何方法进行初始化。

	如果它用于缩小一个内存块，该内存块尾部的部分内存便被拿掉，剩余部分内存的原先内容依然保留。

	如果原先的内存块无法改变大小，realloc 将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的块上。
	因此，在使用realloc 之后，你就不应该再使用指向 旧内存的指针，而是应该改用 realloc 所返回的新指针。

	最后，如果 realloc 函数的第1个参数是NULL，那么它的行为就和 malloc 一模一样。

	如果无法分配内存，也是返回NULL。

	所以正确的使用 realloc 方式是如下这样的：
*/

char* p = malloc(1024);
char* q = realloc(p,2048);

if (q == NULL)		// 说明分配失败
{
	
}
else if (q != p)	// 说明分配内存时，原先那块内存的内容被复制到新的块上了。
{
	p = q;			// p指向的那块地方被  realloc 函数执行 free 了，所有用 q 指向的地址 赋值给 p。
}
else if (q == p)	// 说明分配内存时，新增加的内存添加到原先内存块的后面了。
{
	q = NULL;		// 这时候绝对不能 用 free 了。如果用 free(q)，则p也不能使用了。
}

/* 要避免下面这种写法，*/ 

p = realloc(p,2048);		
/* 当 realloc 分配失败后，返回NULL，则原来指向 那块内存 的地址 则丢失了，你访问不到了。
	也就是遇到了传说中的 内存泄露。
 */ 


// __________________________11.4使用动态分配的内存__________________________

// 这里有一个例子，它用 malloc 分配一块内存

int *pi;
pi = malloc(100);
if (pi == NULL)
{
	printf("Out of memory!\n");
	exit(1);
}	

/* 如果内存分配成功，那么我们就拥有了一个指向100个字节的指针。在整型为4个字节的机器上，
	这块内存将被当作25个整型元素的数组，因为 pi 是一个指向整型的指针 */

/*  如果，你的目标就是获得足够存储25个整数的内存，这里有一个更好的技巧来实现这个目的 */
pi = malloc( 25*sizeof( int ) );

/* 这个方法更好一些，因为它是可移植的。即使是在整数长度不同的机器上，它也能获得正确的结果
	既然你已经有了一个指针，那么你该如何使用这块内存呢？你可以使用 间接访问和指针运算来
	访问数组的不同整数位置，下面这个循环就是这样做的，它把这个新分配的数组的每个元素都初始化为0：
*/

int *pi2,i;

pi2 = pi;
for ( i = 0; i < 25; i++)
{
	*pi2++ = 0;
}

// 不仅可以使用指针，也可以使用下标。下面的第2个循环所执行的任务和前面一个相同。
int i;
for (i = 0; i < 25; ++i)
{
	pi[i] = 0;
}


// __________________________11.5常见的动态内存错误__________________________

/* 在使用动态内存分配的程序中，常常会出现许多错误。这些错误包括对
	1-NULL指针进行解引用操作，
	2-对分配的内存进行操作时越过边界，
	3-释放并非动态分配的内存，
	4-试图释放一块动态分配的内存的一部分
	5-一块动态内存被释放之后被继续使用
 */

/*  警告：
	动态内存分配最常见的错误就是忘记检查所请求的内存是否成功分配。 

	第二大错误来源是操作内存时超出了分配内存的边界。

	当你使用free时，可能出现各种不同的错误。传递给 free 指针必须是一个从 malloc，calloc
	或 realloc 函数返回的指针。传给 free 函数 一个指针，让它释放一块并非动态分配的内存
	可能导致程序立即终止或在晚些时候终止。试图释放一块动态分配内存的一部分也有可能引起类似的问题。
	
	像下面这样：
*/
pi = malloc( 10*sizeof(int));
free(pi + 5); 
/*
	释放一块内存的一部分是不允许的，动态分配的内存必须整块一起释放。但是realloc函数可以
	缩小一块动态分配的内存，有效地释放它尾部的部分内存。
*/


/*  警告：
	最后，你必须小心在意，不要访问 已经被 free 函数释放了的内存。这个警告看上去很显然，但这里
	仍然存在一个很微妙的问题。假定你对一个指向动态分配的内存的指针进行了复制，
	而且这个指针的几份拷贝散布于程序各处。你无法保证当你使用其中一个指针时它所指向的内存是不是已被另一个指针释放。
	另一方面，你必须确保程序中所有使用这块内存的地方在这块内存被释放之前停止对它的使用。
*/


// 内存泄露
/*
	当动态分配的内存不再需要使用时，它应该被释放，这样它以后可以被重新分配使用。
	分配内存但在使用完毕后不释放将引起内存泄露(memory leak)。在那些所有执行程序共享一个通用内存池的操作系统中，
	内存泄露将一点点地榨干可用内存，最终使其一无所有。要摆脱这个困境，只有重启系统。

	其他操作系统能够记住每个程序当前拥有的内存段，这样当一个程序终止时，所有分配给它但未被释放的内存都归还给内存池。
	但即使在这里系统中，内存泄露仍然是一个严重的问题，因为一个持续分配却一点不释放内存的程序最终将耗尽可用的内存。
	
	此时，这个有缺陷的程序将无法继续执行下去，它的失败有可能导致当前已经完成的工作统统丢失。
*/	

// __________________________11.6内存分配实例__________________________
/*
	动态内存分配一个常见的用途就是为那些长度在运行时才知的数组分配内存空间。
	程序11.2读取一列整数，并按升序排列它们，最后打印这个列表。

	用于保存这个列表的内存时动态分配的，这样当你编写程序时就不必猜测用户可能希望对多少个值进行排序。
	可以排序的值的数量仅受分配给这个程序的动态内存数量的限制。
	但是，当程序对一个小型的列表进行排序时，它实际分配的内存就是实际需要的内存，因此不会造成浪费。

	现在让我们考虑一个读取字符串的程序。如果你预习不知道最长的那个字符串的长度，
	你就无法使用普通数组作为缓冲区。反之，你可以使用动态分配内存。
	当你发现一个长度超过缓冲区的输入行时，你可以重新分配一个更大的缓冲区，把该行的剩余部分也装到它里面。
*/

// 程序 11.3 复制字符串
char *strdup( char const *string)
{
	char *new_string;

	// 请求足够长度的内存，用于存储字符串和它的结尾NUL字节。
	new_string = malloc(  strlen(string) + 1);

	// 如果我们得到内存，就复制字符串。
	if (new_string != NULL )
	{
		strcpy( new_string, string );
	}

	return new_string;
}	

// 我们最后一个例子 说明了你可以 怎样使用动态内存分配来消除使用变体记录造成的内存空间浪费。

// 程序11.4是第10章货存系统的修改版本。
// P250/469



// __________________________11.7总结__________________________

/*
	当数组被声明时，必须在编译时知道它的长度。动态内存分配允许程序为一个长度在运行时才知道的数组分配内存空间。

	malloc 和 calloc 函数都用于动态分配一块内存，并返回一个指向该块内存的指针。
	malloc 的参数就是需要分配的内存的字节数。和它不同的是，calloc的参数是你需要分配的元素个数和每个元素的长度。

	calloc函数在返回前把内存初始化为零，而malloc函数返回时内存并未以任何方式进行初始化。

	调用realloc函数可以改变一块已经动态分配的内存的大小。增加内存块大小时有可能采取的方法是把原来内存块上的所有数据
	复制到一个新的，更大的内存块上。

	当一个动态分配的内存块不再使用时，应该调用 free 函数把它归还给可用的内存池。内存被释放之后便不能再被访问。

	如果请求的内存分配失败，malloc ，calloc 和 realloc 函数返回的将是一个NULL指针。错误地访问分配内存之外的区域所引起的后果类似越界访问一个数组，
	但这个错误还可能破坏可用内存池，导致程序失败。如果一个指针不是从早先的 malloc，calloc 或 realloc 函数返回的，它是不能作为参数传递给 free 函数的。
	你也不能只释放一块内存的一部分。

	内存泄露是指内存被动态分配以后，当它不再使用时未被释放。内存泄露会增加程序的体积，有可能导致程序或系统的崩溃。
*/



// __________________________11.8警告的总结__________________________

/*
	1 不检查从 malloc 函数返回的指针是否为 NULL
	2 访问动态分配的内存之外的区域
	3 向 free 函数传递一个并非由 malloc 函数返回的指针
	4 在动态内存被释放之后再访问它。
*/	