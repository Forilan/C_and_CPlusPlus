

//#include "Chapter06.h"

/*
	6.1 内存和地址
	6.2 值和类型
	6.3 指针变量的内容
	6.4 间接访问操作符
	6.5 未初始化和非法的指针
	6.6 NULL指针
*/


// 6.1 内存和地址
/*
	对C程序员，我们只对两件事情感兴趣：
	1 内存中的每个位置由一个独一无二的的地址标识。
	2 内存中的每个位置都包含一个值。

	地址与内容
	如果你记住了一个值的存储地址，你以后可以根据这个地址取得这个值。
	但是，要记住所有这些地址实在是太笨拙了，所以高级语言所提供的特性之一就是通过名字而不是地址来访问内存的位置。
	当然这些名字就是我们所称的变量。有一点非常重要，变量与内存位置之间的关联并不是硬件所提供的，它是由编译器为我们实现的。
	所有这些变量给了我们一种更方便的方法记住地址，硬件仍然通过地址访问内存位置。
*/


// 6.2 值和类型
/*
	不能简单地通过检查一个值的位来判断它的类型。
	一个地址里存储的值，可以被解释成浮点数，也可以被解释成整数。这取决于它们被使用的方式，
	如果使用的是整型算术指令，这个值就被解释为整数，如果使用的是浮点型指令，它就是个浮点数。
*/


int 	a = 112, b = -1;
float 	c = 3.14;
int 	*d = &a;
int 	*e = &c;


// 6.3 指针变量的内容
/*
	指针的初始化是用 & 操作符完成的。
	上例中，a,b,c,d,e的值各是多少呢？
	a为112，b为-1，c为3.14，d为a在内存中的地址,e为c在内存中的地址。
*/


// 6.4 间接访问操作符
/*
	通过一个指针访问它所指向的地址的过程称为间接访问或解引用指针。
	这个用于执行间接访问的操作符是单目操作符*。
	比如d的值 为 a的地址。*d 的值为112。
*/


// 6.5 未初始化和非法的指针
int *a;
*a = 12;
/*
	上面这个代码有一个极为常见的错误：声明了一个名叫a的指针变量，但是没有初始化a的值。
	后面那条赋值语句把12存储在 a 所指向的内存位置。但是究竟a指向哪里呢？
	我们声明了这个变量，但从未对它进行初始化，所以我们没有办法预测12这个值将存储于什么地方。
*/
char a = '在你对指针进行间接访问之前，必须非常小心，确保它们已经被初始化';



// 6.6 NULL指针
/*
	标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使一个指针变量为NULL，你可以给它赋一个零值。
*/


// 6.7 指针，间接访问和左值
/*
	间接访问操作符（*）所需要的操作数是个右值，但这个操作符所产生的结果是个左值。
	*a = 20;
*/

// 6.8 指针，间接访问和变量
*&a = 25;
/*
	上式的意思是：把25赋值给变量a。
	&操作符产生变量a的地址，它是一个指针常量。接着，*操作符访问其他操作数所表示的地址。
	在这个表达式中，操作数是a的地址，所以值25就存储于a中。
	但是一般没人用 *&a 这样的表达式，因为它所产生的目标代码将会更大，更慢。
*/

// 6.9 指针常量
*100 = 25；
/*
	假定变量a存储于位置100，那第1条语句的作用是什么？它看上去像是把25赋值给a,因为a是位置100所存储的变量。
	但是这是错的！这条语句实际上是非法的，因为字面值100的类型是整型，而间接访问操作只能用于指针类型表达式。
	如果想存储于位置100，必须使用强制类型转换。

	但是通常需要用到这个技巧的时候是少之又少。
*/
*(int *) 100 = 25；



// 6.10 指针的指针
int a 	= 12;
int *b 	= &a;
int **c = &b;

/*
	c的类型是什么？显然它是一个指针，或者说是 一个指针的指针。
*/


// 6.11 指针表达式
/*
	这章写的糟糕，还是翻译的糟糕。真心糟糕。
*/


// 6.12 实例
/*
	计算一个字符串的长度
*/

int strlen(char *string)
{
	int length = 0;
	while( *string++ != '\0')
		length += 1;

	return length;
}


// 6.13 指针运算
/*
	指针加上一个整数的结果是另一个指针。问题是，它指向哪里？如果你将一个字符指针加1，运算结果产生的指针指向内存中的下一个字符。
	当一个指针和一个整数量 执行算术运算时，整数在执行加法运算前始终会根据合适的大小进行调整。
	这个“合适的大小”就是指针所指向类型的大小，“调整”就是把整数值和“合适的大小”相乘。
*/