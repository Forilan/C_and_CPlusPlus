

//#include "Chapter13.h"


// __________________________13.1 进一步探讨指向指针的指针__________________________
int	 	i;
int		*pi;
int		**ppi;

pi = &i;
ppi = &pi;
/*
	只有当确实需要时，你才应该使用多层间接访问。不然的话，
	你的程序将会变得更庞大，更缓慢并且难于维护。
*/



// __________________________13.2 高级声明__________________________
int *f();


int (*f)();
/*
	函数指针
	程序中的每个函数都位于内存中的某个位置，
	所以存在指向那个位置的指针是完全可能的。
*/


int *(*f)();	
/*
	和前一个声明基本相同，f也是一个函数指针，只是所指向的函数返回值是一个整型指针，
	必须对其进行间接访问操作才能得到一个整型值。
*/ 


int f[];	// 数组

int *f[];	// 一个数组，指向的元素类型是指向 整型的指针。


int f()[];	
/*
	f是一个函数，它的返回值是一个整型数组。
	这里隐藏了一个圈套，这个声明是非法的，函数只能返回标量值，不能返回数组。
*/ 


int f[]();
/*
	f是一个数组，它的元素类型是返回值为整型的函数。
	这个声明也是非法的，因为数组元素必须具有相同的长度，但不同的函数显然可能具有不同的长度。
*/


int (*f[])();
/*
	这个声明是合法的，
	f是一个数组，数组元素的类型是函数指针，它所指向的函数的返回值是一个整型值。
*/
typedef int (*ptr)();
ptr f[];


int *(*f[])();
/*
	f是一个数组，数组元素的类型是函数指针，
	它所指向的函数的返回值是一个整型指针。
*/
typedef int * (*ptr)();
ptr f[];


// __________________________13.3 函数指针__________________________
/*
	最常见的两个用途是转换表 和 作为参数传递给另一个函数。
*/


/*
	警告：声明一个函数指针并不意味着它马上就可以使用。和其他指针一样，
	对函数指针执行间接访问之前必须初始化为指向某个函数。
*/
int f(int);
int (*pf)(int) = &f;

/*
	初始化表达式中 &操作符是可选的，因为函数名 被使用时总是由编译器把它转换为函数指针。
	&操作符只是显式地说明了编译器将隐式执行的任务。

pf = f;
pf = &f;

	在函数指针被声明并且 初始化之后，我们就可以使用三种方式 调用函数：
*/

int ans;
ans = f(25);
ans = (*pf)(25);
ans = pf(25);


// 13.3.1 回调函数
/*
	回调函数：用户把一个函数指针作为参数传递给其他函数，后者将回调用户的函数。
	任何时候，如果你所编写的函数必须能够在不同的时刻执行不同类型的工作或者执行只能由函数调用者定义的工作，你都可以使用这个技巧。
*/

// 13.3.2 转移表
/*
	下面的代码段取自一个程序，它用于实现一个袖珍式计算器。程序的其他部分已经读入两个数（op1和op2）和一个操作符（oper）.
	下面的代码对操作符进行测试，然后决定调用哪个函数。
*/

switch(oper){
case ADD:
	result = add(op1,op2);
	break;
case SUB:
	result = sub(op1,op2);
	break;
case MUL:
	result = mul(op1,op2);
	break;
case DIV:
	result = div(op1,op2);
	break;
// ... ...
}

/*
	对于一个新奇的具有上百个操作符的计算器，这条switch语句将会非常之长。
	为什么要调用函数来执行这些操作呢？把具体操作和选择操作代码分开是一种良好的设计方案。
	更为复杂的操作将肯定以独立的函数来实现，因为它们的长度可能很长。

	为了使用 switch 语句，表示操作符的代码必须是整数。如果它们是从零开始连续的整数，
	我们可以使用转换表来实现相同的任务。转换表就是一个函数指针数组。

	创建一个转换表需要两个步骤。
*/


double add(double,double);
double sub(double,double);
double mul(double,double);
double div(double,double);

// ... ...

// 首先，声明并初始化一个函数指针数组。
double (*oper_func[])(double,double)={add,sub,mul,div};

// 用下面这条语句替换前面整条switch语句！
result = oper_func[oper](op1,op2);

/*
	oper 从数组中选择正确的函数指针，而函数调用操作符将执行这个函数。
	警告：在转换表中，越界下标引用 就像在其他任何数组中一样是不合法的。
	但一旦出现这种情况，把它诊断出来要困难的多。
*/ 



// __________________________13.4 命令行参数__________________________
/*
	处理命令行参数 是指向指针的指针的另一个用武之地。有些操作系统，包括UNIX和MS-DOS，
	让用户在命令行中编写参数来启动一个程序的执行。这些参数被传递给程序，程序按照它认为合适的任何方式对它们进行处理。
*/

// 13.4.1 传递命令行参数
// 以后待仔细 看这一部分


// __________________________13.5 字符串常量__________________________
/*
	当一个字符串常量出现于表达式中时，它的值是个指针常量。编译器把这些指定字符的一份拷贝存储在内存的某个位置，
	并存储一个指向1个字符的指针。
*/	

"xyz"+1;
/* 	这个表达式什么意思呢？实际是计算：指针值加上1，它的结果是个指针，指向字符串中第2个字符：y 	*/

*"xyz";
// 间接访问的结果就是它所指向的字符：x

"xyz"[2];
// 值就是字符: z


// P270


// 13.6 总结





