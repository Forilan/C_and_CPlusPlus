

// 02-第2章-变量和基本类型


// __________________________2.1 基本内置类型 __________________________

/*
	C++ 定义了一套包括 算术类型 和 空类型 在内的 基本数据类型。
*/

// 2.1.1 算术类型

// 2.1.2 类型转换
/*
	建议：	避免无法预知和依赖于实现环境的行为

	无法预知的行为源于编译器无须（有时是不能）检测的错误。

	程序也应该尽量避免依赖于实现环境的行为。如果我们把 int 的尺寸看出是一个确定不变的已知值，那么这样的程序就称作不可移植的。
	当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。

*/


/*
	提示：	切勿混用带符号类型和无符号类型

	如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负值时会出现异常结果，
	这是因为带符号数会自动地转换成无符号数。
*/







// 转义序列




// __________________________2.2 变量 __________________________



/*	【WARNING】
	初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
*/


// 列表初始化 __________________________

// C++ 语言定义了初始化的好几种不同形式，
int a = 0;
int b = {0};	// 列表初始化
int c{0};		// 列表初始化
int d(0);	

/*
	C++11 新标准，用花括号来初始化变量得到了应用。
	当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化 且 初始值存在丢失信息的风险，则编译器将报错；

*/

long double ld = 3.1415926536
int a{ld},	b = {ld};		// 错误：转换为执行，因为存在丢失信息的危险。
int c(ld),	d = ld;			// 正确：转换执行，且确实丢失了部分值


// 默认初始化 __________________________

/*	【Tip】
	建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初 未始化后程序安全，
	那么这么做不失为一种简单可靠的方法。
*/


// 2.2.2 变量声明和定义的关系 __________________________

/*
	为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

	如果将程序分为多个文件，则需要在文件间 共享代码的方法。
	例如，一个文件的代码可能需要使用另一个文件中定义的变量。
	一个实际的例子是 std::cout 和 std::cin , 它们定义于标准库，却能被我们写的程序使用。

	为了支持分离式编译，C++语言将声明和定义区分开来。
	声明 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
	而定义 负责创建与名字关联的实体。

	变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

	如果想声明一个变量而非定义它，就在变量名前添加关键字 extern,而且不要显式地初始化变量：
*/	

extern int i;		// 声明i 而非定义i
int j;				// 声明并定义j

// 变量能且只能被定义1次，但是可以被多次声明。


// 关键概念：静态类型 __________________________
/*
	C++ 是一种静态类型语言，其含义是在编译阶段检查类型。

	对象的类型 决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，
	如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。

	程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，
	这就要求我们在使用某个变量之前必须声明其类型。
*/


// 2.2.3 标识符 __________________________	


/*
	C++ 标识符 由 字母，数字，下画线组成，其中必须以字母或下画线开头。
	标识符的长度没有限制，但是对大小写字母敏感。

	同时C++ 也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个小画线，也不能以下画线紧连大写字母开头。
	此外，定义在函数体外的标识符不能以下画线开头。
*/


// error define name:
int __sfsf;
int _Asdfas;
int _ssf;		// 在函数体外的标识符


// 2.2.4 名字的作用域 __________________________	


#include <iostream>

int reused = 42;

int main()
{
	int unique = 0;
	std::cout << reused << " " << unique << std::endl;		// 输出 42 0 

	int reused = 0;
	std::cout << reused << " " << unique << std::endl;		// 输出 0 0 

	std::cout << ::reused << " " << unique << std::endl;	// 输出 42 0 


	return 0;
}	

// __________________________2.3 复合类型 __________________________

/*
	复合类型 是指基于 其他类型 定义的类型。
	本章介绍2种：引用和指针。

*/


// 关键概念：某些符号有多重含义
// P48


// 好累啊。。。	