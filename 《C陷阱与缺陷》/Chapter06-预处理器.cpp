

#include "Chapter06.h"



// 第6章 预处理器

/*
	严格意义上的 编译过程 开始之前，C语言预处理器 首先对 程序代码作了必要 的转换处理。
	因此，我们运行的程序 实际上 并不是我们所写 的程序。
	预处理器 使得编程者 可以简化某些操作，它的重要性 可以 由两个主要的 原因 说明。

	第一个原因：我们也许需要 将某个 特定数量 在 程序中出现的 所有实例 统统加以修改。


	第二个原因：大多数C语言实现 在 函数调用时 都会带来重大的 系统开销。
	因此，我们也许希望有这样一种程序块，它看上去像一个函数，但却没有函数调用的开销。

	虽然宏非常有用，但如果程序员没有认识到 宏 只是对程序的文本起作用，那么很容易对宏产生迷惑。
	因而，宏既可以 
	使一段看上去完全不合语法的代码 成为一个有效的C程序，
	也能使一段看上去无害的代码成为一个可怕的怪物。
*/


// 6.1 不能忽视宏定义中的空格
#define f(x) ((x) - 1)
#define g (x) ((x) - 1)
/*
	第1个 代表		((x) - 1)
	第2个 代表		(x) ((x) - 1)
*/


// 6.2 宏不是函数
#define abs(x)	x>0?x:-x
/*
	为了防止出现一些莫名的错误，最好在宏定义中把每个 参数都用 括号括起来，同样，整个结果表达式也应该用括号括起来，。
*/
#define abs(x) ((x)>=0?(x):-(x))


// 6.3 宏并不是语句
/*
	assert, 可以产生"断言失败"的出错消息。
*/


// 6.4 宏并不是类型定义
#define FOOYTPE struct foob
FOOYTPE a;
FOOYTPE b,c;

/*
	宏的一个常见用途是，使多个不同变量的类型可在一个地方说明
	宏定义的这种用法有一个优点——可移植性，得到了所有C编译器的支持。但是，我们最好还是使用类型定义：
*/

typedef struct foo FOOTYPE;
FOOTYPE a;

#define T1 struct foo*
typedef struct foo *T2;

/*
	从上面两个定义来看，概念上完全相同，都是指向结构 foo 的指针。
	但是当我们 试图用它们来声明多个变量时，问题就来了：
	T1 声明的 a 被定义为一个指向结构的指针，b被定义为一个结构（而不是指针）
	T2 声明的 a 和 b 都是指向结构的指针。
*/

T1 a,b;
T2 a,b;