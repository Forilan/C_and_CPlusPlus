
#include<stdlib.h>
#include<cstdio>
#include<stdlib.h>
#include <cstdio>
#include <iostream>
//using namespace std;

// 03-第3章-字符串、向量和数组

//=========================================================================
//
//							3.1 命名空间的 using 声明
//
//=========================================================================

/*
	有了 using 声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。

	每个名字都需要独立的 using 声明

	头文件不应包含 using 声明。 -- 防止命名空间污染问题。

*/

//using namespace std;
using std::cin;


//=========================================================================
//
//							3.2 标准库类型 string
//
//=========================================================================

/*
	标准库类型 string 表示可变长 的字符序列， 使用 string 类型必须 首先包含 string头文件。
	作为标准库的一部分， string 定义在命名空间 std 中。
*/

#include <string>
using std::string;

// 3.2.1 定义和初始化 string 对象 __________________________
/*
	
*/


// 初始化 string 对象的方式
void string_study_init()
{
	string s1;				// 默认初始化，s1 是一个空串。
	string s2(s1);			// s2 是 s1 的副本。
	string s3 = s1;
	string s4("value");
	string s5 = "value";
	string s6(10, 'c');		// 把 s6 初始化为 由连续n个字符c组成的串
}

/*	【直接初始化和拷贝初始化】
	
	如果使用的 等号（=）初始化一个变量，实际上执行的是【拷贝初始化】，编译器把等会右侧的初始拷贝到新创建的对象中去。
	与之相反，如果不使用等会，则执行的是【直接初始化】。
*/ 


// 3.2.2 string 对象上的操作 __________________________
// 各种 操作符，P77
using namespace std;

// 读写 string 对象
/*
	在执行读取操作时，string 对象会自动忽略开头的空白（即空格符，换行符，制表符）
	并从第一个真正的字符开始读起,直到遇见下一处空白为止。
*/ 
void string_study_operational()
{
	string s;
	cin >> s;			
	cout << s << endl;
}

// 读取未知数量的 string 对象
void string_study_while()
{
	string word;
	while (cin >> word) {
		cout << word << endl;
	}
}

// 使用 getline 读取一整行
// p78


//=========================================================================
//
//							3.3 标准库类型 vector
//
//=========================================================================

/*
	标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。集合中每个对象都有一个与之对应的索引，索引用于访问对象。
	因为 vector 容纳着其他对象，所以它也常称作容器。
*/
// 所需的头文件
#include <vector>
using std::vector;

/*
	C++ 语言既有 类模板，也有函数模板。 其中 vector 是一个【类模板】。
	模板本身不是类或函数，相反可以将 模板 看作为编译器生成类或函数编写的一份说明。
	编译器 根据模板创建类或函数的过程 称为 实例化。

	当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
	以 vector 为例，提供的额外信息是 vector 内所存放对象的类型。
*/




// 3.3.1 定义和初始化 vector 对象 __________________________
/*
	vector 模板控制着 定义和初始化向量的方法。
*/

void vector_study_init()
{
	int n = 10, val = 20;

	vector<int> v1;
	vector<int> v2(v1);
	vector<int> v3 = v1;
	vector<int> v4 (n, val);		// v4 包含了n个重复的元素，每个元素的值都是 val
	vector<int> v5 (n);				// v5 包含了n个重复地执行了值初始化的对象
	// vector<int> v6 {1,2,3,4};		// VS2012 还不支持
	// vector<int> v6 = {1,2,3,4};		// VS2012 还不支持


	int a[9] = {1,2,3,4,5,6,7,8,9};
	vector<int> v(a, a+9);
}

/*	【列表初始化vector对象】
	P88 以后等编译器支持了 再学习。
*/ 

// 3.3.2 向 vector 对象中添加元素 __________________________
/*
	
*/

void vector_study_push()
{
	vector<int> v2;
	for (int i = 0; i < 100; ++i) {
		v2.push_back(i);
	}
}

/*
	如果 循环体内部包含 有向 vector 对象添加元素的语句，则不能使用范围 for 循环。 for (auto &i : v){}
	【因为改变vector大小后，for循环会越界】
	范围for语句体内不应改变其所遍历序列的大小
*/

// 3.3.3 其他 vector 操作 __________________________
/*
	
*/

// 表3.5： vector 支持的操作
void vector_study_other_operational()
{
	vector<int> v,v1,v2;
	bool isEmpty = v.empty();			// 如果 v 中含有任何元素，返回真，
	v.size();
	v.push_back(1);		// 向v的尾端 添加一个值为 t 的元素
	v[0];
	v1 = v2;
	bool isSame = (v1 == v2);			// v1 和 v2 相等【需要元素数量相等，且对应位置的元素值都相同】
	// <, <=, >, >=		// 顾名思义，以字典顺序进行比较
}

void vector_study_other_operational1()
{
	// 访问 vector 对象中元素的方法和访问 string 对象中字符的方法差不多，也是通过元素在 vector 对象中的位置。
	int a[9] = {1,2,3,4,5,6,7,8,9};
	vector<int> v(a, a+9);

	for (auto &i : v)	// 对于v中的每个元素（注意：i 是一个引用）
	{
		i *= i;
	}

	for (auto &i : v)
	{
		cout << i << " ";
	}

	cout << endl;
}

/*
	vector 对象 的小标运算符 可用于访问已存在的元素，而不能用于添加元素。

	确保下标合法的一种有效手段就是尽可能的使用【范围for语句】 for (auto &i : v)
	但是在 使用 【范围for语句】 的时候，不能够 进行修改容器大小的操作。
*/ 


//=========================================================================
//
//							3.4 迭代器介绍
//
//=========================================================================

/*
	我们已经知道可以通过下标运算符来访问 string 对象的字符 或 vector 对象的元素，还有另外一种更通用的机制可以实现同样的目的。
	这就是 迭代器（iterator）
*/ 


// 3.4.1 使用迭代器 __________________________
/*
	和指针不一样的是，获取迭代器不是使用取地址符，拥有迭代器的类型同时拥有返回迭代器的成员。
	比如这些类型都拥有名为 begin() 和 end() 的成员。
*/

void iterator_study_use()
{
	int a[9] = {1,2,3,4,5,6,7,8,9};
	vector<int> v(a, a+9);

	auto b = v.begin(), e = v.end();
	// 如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。
}

// 迭代器运算符
/*
	
*/

// 表3.6 标准容器迭代器
#if 0
	*iter		// 返回迭代器 iter 所指元素的引用
	iter->mem	// 解引用iter并获取该元素的名为 mem 的成员，等价于(*iter).mem
	++iter
	--iter
	iter1 == iter2
	iter1 != iter2
#endif


