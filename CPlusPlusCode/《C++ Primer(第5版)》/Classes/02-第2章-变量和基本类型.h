
#include<stdlib.h>
#include<cstdio>
#include<stdlib.h>
#include <cstdio>
#include <iostream>
using namespace std;

// 02-第2章-变量和基本类型


//=========================================================================
//
//							2.1 基本内置类型 
//
//=========================================================================

/*
	C++ 定义了一套包括 算术类型 和 空类型 在内的 基本数据类型。
*/

// 2.1.1 算术类型

// 2.1.2 类型转换
/*
	建议：	避免无法预知和依赖于实现环境的行为

	无法预知的行为源于编译器无须（有时是不能）检测的错误。

	程序也应该尽量避免依赖于实现环境的行为。如果我们把 int 的尺寸看出是一个确定不变的已知值，那么这样的程序就称作不可移植的。
	当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。

*/


/*
	提示：	切勿混用带符号类型和无符号类型

	如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负值时会出现异常结果，
	这是因为带符号数会自动地转换成无符号数。
*/

// 练习2.3

void cout2unsign()
{
	unsigned u = 10, u2 = 42;
	std::cout << u2 - u << std::endl;	// 32
	std::cout << u - u2 << std::endl;	// 4294967264

	int i = 10, i2 = 42;
	std::cout << i2 - i << std::endl;	// 32
	std::cout << i - i2 << std::endl;	// -32
	std::cout << i - u << std::endl;	// 0
	std::cout << u - i << std::endl;	// 0

}

// 2.1.3 字面值常量

/*
	一个形如 42 的值被称作 字面值常量（literal）,
*/

// 整型和浮点型字面值
/*
	可以将整型字面值 写作 十进制，八进制，十六进制数的形式。
	以0开头的整数代表八进制数，
	以0x或0X开头的代表十六进制数。
*/

void test0and0x()
{
	cout << 10 << endl;
	cout << 010 << endl;
	cout << 0x10 << endl;
	cout << 0X10 << endl;
	cout << 07 << endl;

}

// 字符和字符串字面值
/*
	由单引号括起来的一个字符称为 char 型字面值，
	双引号括起来的零个或多个字符则构成字符串型字面值。

	字符串字面值的类型 实际上是由常量字符构成的数组，编译器在每个字符串结尾处添加一个空字符'\0'
	因此字符串字面值的实际长度比它的内容多1.

	如果两个字符串字面值位置紧邻且仅由空格，缩进和换行符分隔，则它们实际上是一个整体。
*/

void testcharAndString()
{
	cout << 'a' << endl;
	cout << "sfjlkds " << endl;
	cout << "asf456 "  
		"lsdflk " << endl;

	string te1 = "sdj123";
	string te2 = "fsj456";

	cout << te1.c_str() << te2.c_str() << endl;
}


// 转义序列
/*
	有两类字符程序员 不能直接使用：
	一类是不可打印的字符。
	一类是C++语言中有特殊含义的字符（单引号，双引号，问号，反斜线）

	这些情况下需要用到转义序列。
*/

// 指定字面值的类型

void checkLiteralType()
{
	float er = 3.0f;
	cout << 1.0f << endl;
	cout << 2.0L << endl;
	cout << er << endl;
}



//=========================================================================
//
//								2.2 变量 
//
//=========================================================================


/*	【WARNING】
	初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
*/


// 列表初始化 __________________________

// C++ 语言定义了初始化的好几种不同形式，
void init()
{
	int a = 0;
	int b = {0};	// 列表初始化
	//int c{0};		// 列表初始化-	VS2012 还不支持。
	int d(0);

/*
	C++11 新标准，用花括号来初始化变量得到了应用。
	当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化 
	且 初始值存在丢失信息的风险，则编译器将报错；
*/
	if(1) {
		long double ld = 3.1415926536;
		//int a{ld},	b = {ld};		// 错误：转换为执行，因为存在丢失信息的危险。
		int c(ld),	d = ld;			// 正确：转换执行，且确实丢失了部分值
	}
	
}






// 默认初始化 __________________________

/*	
	如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。
	默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

	如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。
	定义于任何函数体之外的变量被初始化为0.
	但是定义于函数体之内的内置类型变量 将不被初始化。

	【Tip】
	建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初 未始化后程序安全，
	那么这么做不失为一种简单可靠的方法。
*/

std::string global_str;
int global_int;

void defaultInit()
{
	int local_int;
	std::string local_str;

	cout << global_str.c_str() << endl;
	cout << global_int << endl;
}




// 2.2.2 变量声明和定义的关系 __________________________

/*
	为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

	如果将程序分为多个文件，则需要在文件间 共享代码的方法。
	例如，一个文件的代码可能需要使用另一个文件中定义的变量。
	一个实际的例子是 std::cout 和 std::cin , 它们定义于标准库，却能被我们写的程序使用。

	为了支持分离式编译，C++语言将声明和定义区分开来。
	声明 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。
	而定义 负责创建与名字关联的实体。

	变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

	如果想声明一个变量而非定义它，就在变量名前添加关键字 extern,而且不要显式地初始化变量：
*/	
#if 0
extern int i;		// 声明i 而非定义i
int j;				// 声明并定义j
#endif
// 变量能且只能被定义1次，但是可以被多次声明。


// 关键概念：静态类型 __________________________
/*
	C++ 是一种静态类型语言，其含义是在编译阶段检查类型。

	对象的类型 决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，
	如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。

	程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每一个实体对象的类型，
	这就要求我们在使用某个变量之前必须声明其类型。
*/



// 2.2.3 标识符 __________________________	

/*
	C++ 标识符 由 字母，数字，下画线组成，其中必须以字母或下画线开头。
	标识符的长度没有限制，但是对大小写字母敏感。

	同时C++ 也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个小画线，也不能以下画线紧连大写字母开头。
	此外，定义在函数体外的标识符不能以下画线开头。
*/


// error define name:
int __sfsf;
int _Asdfas;
int _ssf;		// 在函数体外的标识符

#if 0
int double = 3.14;		// C++关键字
int _;					// 正常使用 - 但是绝对会被人骂死
int catch-22;			// C++关键字
int 1_or_2 = 1;			// 必须以字母或下划线开头
double Double = 3.14;	// 正常使用 - 但是绝对会被人骂死
#endif




// 2.2.4 名字的作用域 __________________________	

/*
	全局作用域	（global scope）
	块作用域	（block scope）
*/

int reused = 42;

int test_scope()
{
	int unique = 0;
	std::cout << reused << " " << unique << std::endl;		// 输出 42 0 

	int reused = 0;
	std::cout << reused << " " << unique << std::endl;		// 输出 0 0 
	std::cout << ::reused << " " << unique << std::endl;	// 输出 42 0 
	/*
		因为全局作用域 本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。
	*/

	return 0;
}	

/*	
	【Tip】
	如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。
*/

//=========================================================================
//
//								2.3 复合类型 
//
//=========================================================================

/*
	复合类型 是指基于 其他类型 定义的类型。
	本章介绍2种：引用和指针。

*/

// 2.3.1 引用 __________________________

/*
	C++11 中新增了一种引用：右值引用。这种引用 主要用于内置类型。
	现在我们只说  引用 时，其实指的是 左值引用。
*/

/*
	【引用 为对象起了另外一个名字，引用类型引用 另外一种类型。】
	通过将声明符写成 &d 的形式来定义 引用类型，其中 d 是声明的变量名。

	一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

	引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。【不就是指针么】

	因为引用本身不是对象，所以不能定义引用的引用。【这句话 毛线意思？】

	除了2种特殊情况，其他所有引用的类型都要和与之绑定的对象严格匹配。
	而且，引用只能绑定在对象上，而不能与 字面值或某个表达式的计算结果绑定在一起。
*/

void test_referenece()
{
	int ival = 1024;
	int &refval = ival;
	//int &refval2;

	int &refval3 = refval;	// 这里实际是 定义了 ival 的引用，而非是 refval 的引用。
	refval3 = 10125;

	// 练习 2.15
#if 0		// wrong code test
	int &refval2;
	int &refval4 = 96;
	int &refval5 = 1.01;
	double sdf = 3.14;
	int &refval6 = sdf;
#endif

	// 练习 2.16
	int i = 0, &r1 = i;
	double d = 0, &r2 = d;
	r2 = 3.14159;
	r2 = r1;
	i = r2;
	r1 = d;

	// 练习 2.17
	int j, &rt = j;
	j = 5;
	rt = 10;
	std::cout << j << " " << rt << std::endl;	
}



// 2.3.2 指针 __________________________

/*
	【指针 是 指向另外一种类型的 复合类型】

	指针与引用 有很多不同的地方：
	一：指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。
	二：指针无须在定义时赋初值。

	获取对象的地址：
	指针存放某个对象的地址，要想获取该地址，需要使用取地址符。
*/

void pointer_study()
{
	int ivel = 42;
	int *p = &ivel;
}

/*	【指针值】
	指针的值（即地址）应属下列4种状态之一：
	1.指向一个对象。
	2.指向紧邻对象所占空间的下一个位置。
	3.空指针，意味着指针没有指向任何对象。
	4.无效指针，也就是上述情况之外的其他值。
*/

/*	【利用指针访问对象】
	如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象。

	解引用操作仅适用于那些确实 指向了某个对象的有效指针。
*/
void pointer_study1()
{
	int ivel = 42;
	int *p = &ivel;
	cout << *p;

	*p = 0;
	cout << *p;
}

/*	【关键概念：某些符号有多重含义】
	在声明语句中， & 和 * 用于组合复合类型；
	在表达式中，它们的角色又转变成 运算符。
	不不同的场景下出现的虽然是同一个符合，但是由于含义截然不同，所以我们完全可以把它当作不同的符号来看待。
*/ 

void pointer_study2()
{
	int i = 42;
	int &r = i;
	int *p;
	p = &i;
	*p = i;
	int &r2 = *p;
}

/*	【空指针】
	空指针 不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。

	使用未经初始化的指针是引发运行时错误的一大原因。
*/ 

void pointer_null()
{
	int *p1 = nullptr;
	int *p2 = 0;
	int *p3 = NULL;
}

/*	【void* 指针】
	void 是一种特殊的指针类型，可用于存放任意对象的地址。

	一个 void* 指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

	利用 void* 指针能做的事儿比较有限：
	1拿它和别的指针比较、
	2作为函数的输入和输出，
	3或者赋给另外一个 void* 指针。
*/ 


// 2.3.3 理解复合类型的声明 __________________________

/*
	变量的定义包括一个基本数据类型（base type）和一组声明符。
	在同一条语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。
	也就是说，一条定义语句可能定义出不同类型的变量：
*/

void type_study()
{
	int i = 1024, *p = &i, &r = i;		// i 是一个 int 型的数， p 是一个int型指针，r是一个int型引用。
}

/*	WARNING
	很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。	
*/


/*	【定义多个变量】
	经常有一种观点认为，在定义语句中，类型修饰符（*或&）作用于本次定义的全部变量。
	造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间。
	int* p; 

	int* 放在一起好像是这条语句中所有变量共同的类型一样。其实恰恰相反，基本数据类型是 int 而非 int*.
	* 仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用。
	int* p1, p2;

	int *p;	【还是觉得这样写来好一点】
*/

/*	【指向指针的指针】
	一般来说，声明符中修饰符的个数并没有限制。

	int ival = 1023;
	int *p = &ival;
	int **p = &p;
*/ 

/*	【指向指针的引用】
	引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。
*/ 

void type_study1()
{
	int i = 42;
	int *p;
	int *&r = p;	// r 是一个对指针p的引用

	/*	 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。  */

	r = &i;
	*r = 0;
}

//=========================================================================
//
//								2.4 const 限定符 
//
//=========================================================================


/*	【初始化和const】
	const 对象一旦创建后其值就不能再改变，所以 const 对象必须初始化。

	对象的类型决定了其上的操作。
	与非 const类型所能参与的操作对比，const类型的对象的主要限制 就是只能在 不改变其内容的操作。 
*/ 

void const_study()
{
	const int  er = 2;

}

/*	【默认状态下，const对象仅在文件内有效】
	编译器将在编译过程中把用到该变量的地方都替换成对应的值。
*/ 

const int bufsize = 1024;		// 输入缓冲区大小
// 等价于下式
static const int bufsize1 = 1024;

/*
	如果想在 多个文件之间共享const对象，必须在变量的定义之前添加 extern 关键字。
*/

// file1.cpp
extern const int buf1 = 512;
// file2.cpp
extern const int buf1;

// 2.4.1 const的引用 __________________________

/*
	可以把引用绑定到 const 对象上,就像绑定到其他对象上一样,称之为 对常量的引用[reference to const].
*/

void const_referenece_study()
{
	const int ci = 1024;
	const int &er = ci;

#if 0
	er = 42;		// 错误， er 是对常量的引用
	int &r2 = ci;	// 错误，试图让一个非常量引用指向一个常量对象
#endif

}

/*	【初始化和对const的引用】
	引用的类型必须与其所引用对象的类型一致，但是有两个例外。

	第1种例外情况：
	【就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成 引用的类型即可。】

	这底下我都看糊涂了啊。
*/ 

void const_referenece_study1()
{
#if 0
	double dval = 3.14;
	const int &ri = dval;
	// 等价与下面
	const int temp = dval;
	const int &ri = temp;
#endif

	// 所有下面的 初始化就都是合法的了。
	int i = 42;
	const int &r1 = i;
	const int &r2 = 42;
	const int &r3 = r1 * 2;

	// int &r4 = r1 * 2;	// 错误。r4 是一个非常量引用。 【非常量引用的初始值必须为左值。】
}

// 对 const 的引用可能 引用一个并非const的对象
void const_referenece_study2()
{
	int i = 42;
	int &r1 = i;
	const int &r2 = i;
	r1 = 0;
}

// 2.4.2 指针和const __________________________
/*
	与引用一样，也可以令指针指向常量或非常量。
	类似于常量引用，指向常量的指针不能用于改变其所指对象的值。
	要想存放常量对象的地址，只能使用指向常量的指针。

	指针的类型 必须 与其所指对象的类型一致，但是有两个例外。其中一个例外就是：
	【允许另一个指向常量的指针指向一个非常量对象。】
*/

void pointerToConst()
{
	const double pi = 3.14;
	//double *ptr = &pi;		// 错误。
	const double *cptr = &pi;
	//*cptr = 42;				// 错误。

	double dval = 3.14;
	cptr = &dval;				// 正确，那种例外情况。
}

/*	【const指针】
	指针是对象而引用不是，所以就允许指针本身定为常量。
	常量指针【const pointer】 必须初始化。
*/ 

void test_const()
{
	// 练习 2.27
	const int i = -1, &r = 0;	// const 是对 int 进行限制了。
	int const j = -1, &e = 0;

#if 0
	const int &const r2;		// 错误
	int i, * const cp;			// cp 必须初始化
	const int * const p3;		// p3 必须初始化
	int *p1, *const p2;			// p2 必须初始化
#endif
	const int *p;
	p = &i;
	p = &j;	
}

// 2.4.3 顶层const __________________________

/*
	指针本身是一个对象,	它又可以指向另外一个对象. 因此,
	指针本身是不是常量 以及 指针所指的是不是一个常量 就是两个相互独立的问题.

	用名词 顶层const 表示指针本身是个常量，而用名词底层const 表示指针所指的对象是一个常量。
*/

void test_const_top_low_level()
{
	// 2.4.3节练习
	// P58~待做
}

// 2.4.4 constexpr 和 常量表达式 __________________________
// P58 ~ P60 以后等用了 VS2014编译器，支持了再学吧
void constexpr_study()
{
#if 0
	constexpr int mf = 20;		// VS2012 不支持
#endif

	// 2.4.4节练习
	//int null = 0, *p = null;
	int null = 0, *p = 0;
}


//=========================================================================
//
//								2.5 处理类型 
//
//=========================================================================

// 2.5.1 类型别名（type alias） __________________________
/*
	有两种方法可用于定义类型别名。
	1-传统的方法是使用关键字 typedef
	2-使用 using
*/

void typealias_study()
{
	typedef double wages;
	typedef wages base, *p;

	typedef int Sales_item;
	using SI = Sales_item;

	// 区别。
	typedef char * pstring;
	const pstring cstr = 0;		// cstr 的值不能修改了。

	const char * cstr1 = 0;		// cstr1 的值可以修改
	char a;
	cstr1 = &a;
}

// 2.5.2 auto类型说明符 __________________________
/*
	auto 定义的变量 必须有初始值。
*/

void auto_study()
{
	auto i = 0, *p = &i;
	//auto sz = 0, pi = 3.14;		// ERROR, sz 和 pi 的类型不一样.
}

/*	【复合类型、常量和auto】
	编译器推断出来的auto 类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
*/ 

void auto_study()
{
	// 第1种情况
	int i = 0, &r = i;
	auto a = r;	// a 会是 int型。

	// 第2种情况, 一般会忽略掉 顶层 const 
	const int ci = i, &cr = ci;
	auto b = ci;
	auto c = cr;
	auto d = &i;
	auto e = &ci;

	// 2.5.2节练习 - P62
}

// 2.5.3 decltype 类型指示符 __________________________
/*
	希望从表达式的类型推断出要定义的变量的类型，但是不想用 该表达式的值初始化变量。
	C++11 引入了第2种类型说明符：decltype,它的作用是选择并返回操作数的数据类型。
*/
void decltype_study()
{
	int er = 4;
	decltype(er) sum = 3;

	// 2.5.3节练习 - P64
}


//=========================================================================
//
//								2.6 自定义数据结构 
//
//=========================================================================
