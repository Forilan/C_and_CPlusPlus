


class LvalueAndRvalue
{
public:
	void aboutaddadd(void);
	int addaddVar(int &i);
	int VarAddAdd(int &i);
};


/*
	首先看一段文章
	一. 这个问题牵涉到得首先是左值(L-value)和右值(R-value)的概念;

	1. 我查资料的时候发现很多地方都引用一句话:"通俗的讲，左值就是能够出现在赋值符号左面的东西，而右值就是那些可以出现在赋值符号右面的东西了。"
	我觉得这句话在刚开始理解的时候是什么用都没有的一句废话.因为我们都不知道哪些东西应该放在赋值符号的左边,
	哪些东西又应该放在赋值符号的右边这样说是没有意义的.

	2.接着我找到个比较靠谱的定义:左值是指具有对应的可由用户访问的存储单元，并且能由用户改变其值的量。
	如一个变量就是一个左值，因为它对应着一个存储单元，并可由编程者通过变量名访问和改变其值。

	(下面的第三点是c++primer中的)

	3.变量和文字常量都有存储区，并且有相关的类型。区别在于变量是可寻址的（addressable）对于每一个变量都有两个值与其相联：

	1).它的数据值，存储在某个内存地址中。有时这个值也被称为对象的右值（rvalue,读做are-value）.
	我们也可认为右值的意思是被读取的值（read   value）。   文字常量和变量都可  被用作右值。   

	2).它的地址值——即存储数据值的那块内存的地址。它有时被称为变量的左值（lvalue，读作ell-value）。
	我们也可认为左值的意思是位置值location   value文字常量不能被用作左值

	到这里,左值和右值的基本概念应该清楚了.而一些牛人追求的更细致的到C89和C99以及C++标准上面的差异就不在我的思考范围了:)


	二.再讲讲i++和++i的实现

	原来也一直迷惑于i++与++i的返回值的问题,但一直没弄明白.这次一并查清楚吧.

	首先对于i++的实现是：   

	int   temp;   

	temp   =   i;   
	i   =   i+1;   
	return   temp;   
	而++i的实现是：   
	i   =   i+1;   

	return   i;               

	所以对于我们提出来的问题已经能得到解决了:

	i++=5; 是错误的是因为i++返回的是编译器自动分配的临时变量temp,而这个temp并不是你程序中定义的可寻址变量的引用,
	也就是说你不能通过地址对它进行操作.(换句话说就是不能作为左值)

	++i=5;是正确的就是因为其返回值就是i;


	再啰嗦几句关于i++和++i的效率问题:
	按上面分析来说,++i的效率是比i++效率高些的.（VC）对于内置(built-in)类型【比如 int long float 等内置类型】，
	写（++变量）和（变量++）编译器都经过优化，采用（++变量）的方式.
	
	但是对于自定义类对象如果重载先＋＋，
	和后＋＋操作符那么要使用先＋＋，因为这时编译器，不可能对你的类型进行优化！   
*/