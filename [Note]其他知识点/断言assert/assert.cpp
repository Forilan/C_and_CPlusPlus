

// assert


// __________________________1 C语言中assert（断言）的使用 __________________________
/*
	程序一般分为Debug 版本和Release 版本，Debug 版本用于内部调试，Release 版本发行给用户使用。
	assert(表达式); 的意思是：当表达式为真时，程序继续运行，如果表达市为假，那程序就会停止运行，并提示错误信息。

	注意：assert是一个宏，只在debug版本中起作用，在release版本中，该语句是不起任何作用的。

	assert()执行条件为未定义 NDEBUG，在定义该宏时，assert不进行判断，因此常在调试模式下使用断言，而在release下移除断言。
	由于在release模式下，assert() 宏展开仅为((void)0)， 
	因此，不能将功能代码写在assert(…)中.
*/

/*
	使用场合:
	用于判断空指针 assert(pointer) 以及函数参数的数值(assert(a>4))，文件存在与否等
*/

#include <stdio.h>
#include <assert.h>

void test(int *p)
{
  assert(p != NULL);
  printf("%d\n", *p);
}

int main(void)
{
  test(NULL);
}

/*
程序说明：由于我们在main函数中传了NULL指针值给test函数，在test函数执行到assert(p != NULL);
发现表达式不为真，就终止了程序的运行，并提示错误的行数信息。
 
以下摘自《C高效编程》

【规则6-5-1】使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。
【规则6-5-2】在函数的入口处，使用断言检查参数的有效性（合法性）。
【建议6-5-1】在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。
【建议6-5-2】一般教科书都鼓励程序员们进行防错设计，但要记住这种编程风格可能会隐瞒错误。
当进行防错设计时，如果“不可能发生”的事情的确发生了，则要使用断言进行报警。
*/




// __________________________ 宏 assert(_Expression)  定义 __________________________
/* ******************* 文件<assert.h> ******************* */
#ifdef  NDEBUG
	#define assert(_Expression)     ((void)0)
#else
	#define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) )
#endif  /* NDEBUG */
// ~~~~~~~~~~~~~~~~~~~~~~~~~ 说明 ~~~~~~~~~~~~~~~~~~~~~~~~~
/*
	①头文件<assert.h>中除了定义宏assert以外还引用了另外一个宏 NDEBUG，后者不是定义在<assert.h>中的。
	如果NDEBUG出现在任何包含<assert.h>的文件中，并被定义为宏名，那么宏assert就直接被定义为：
	assert(_Expression)     ((void)0)
	
	隐藏函数 _wassert()：这个函数返回值为空
*/    

// ② NDEBUG 开关 ~~~~~~~~~~~~~~~~~~~~~~~~~
NDEBUG宏是VC下Release与Debug版本的开关	
可以很清楚的看 到assert(_Expression)是一个宏，在Release版本下解析为((void)0)。
这种写法，把0强制转换成空类型？平时编码的时候也很少看见。
经过编译后看汇编执行，这一行没有在代码段里面，应该是被编译器直接过滤掉了。
// C++ 代码：
	int a = 7;
	((void)0);
	(1,2,0);
	int b = 8;
// 编译后的 汇编代码：
	int a = 7;
00BAF029  mov         dword ptr [a],7  
	((void)0);
	(1,2,0);
	int b = 8;
00BAF030  mov         dword ptr [b],8 
/* 可以看到 ((void)0); 与 (1,2,0); 都没有生成汇编代码，被编译器直接干掉了 */


// ③ !!(_Expression) 两次取否的妙用 ~~~~~~~~~~~~~~~~~~~~~~~~~
这样的用意是让编译器认为_Expression是一个bool数值
(!!a)有重载符号!两次后看似没有变化，其实是将a转换成明显的bool语意

// ④ (,,0): 逗号表达式的妙用 ~~~~~~~~~~~~~~~~~~~~~~~~~
例如：
int i = (func1(...),func2(...),0);
会顺序求值，可以认为是：
func1(...);
func2(...);
int i = 0;
这样可以保证一些用宏实现的“函数”没有返回值的问题，这样 返回值一点是0。
这样 (!!(_Expression))||(,,0)  表达式就能通过编译了，||左右两边都是bool型了。

// ⑤ ||运算的截断  ~~~~~~~~~~~~~~~~~~~~~~~~~
前面为 true 时就，不执行后面的话。
(!!(_Expression)) ||(,,0): ||运算需要 左右两边的表达式为bool,而 _wassert返回为空，所以使用逗号表达式来返回为0【可以转为bool，填true/false也可】

// ⑦ (void)消除 宏函数的 返回值  ~~~~~~~~~~~~~~~~~~~~~~~~~
去掉这个(void) 就会有返回值冲突问题，返回值到底是什么类型比较好？
bool?
成功时一定是 true,
失败时就会报错。

一般宏“函数”少用返回值，因为一些宏函数的返回值会显得很荒谬。宏是简单的展开，可能会有多句语句复合，
那么返回值就没有函数这种概念来的有意义，通常宏函数只是用于展开一些完成一个功能的集合而不是一个函数。
此外，assert需要返回值吗？？？
确实不需要。

// ⑧ _CRT_WIDE(x)  ~~~~~~~~~~~~~~~~~~~~~~~~~
 _CRT_WIDE(x)宏是把x展开为L##String形式，也就是成为一个宽字节的字符串，无论传进去的是什么内容，都统统转为宽字节字符串。
 对于C语言中井号的用法，简单来说，#x是转换成”x“，也就是展开为字符串 ；L##x是转换成Lx，也就是展开成连接串。


// ⑨ _wassert()  ~~~~~~~~~~~~~~~~~~~~~~~~~
_wassert()函数就是跳出窗口的函数？？？
这个跟 系统 绑定很紧，主要是看VC下 是如何实现的。


// 总结 ~~~~~~~~~~~~~~~~~~~~~~~~~
微软的这种实现 assert()，就是希望没有可以找茬的机会，用近乎无聊的限制来弥补宏的先天不足,就像BS说过的“宏是万恶之源”.
微软试图堵塞这个可能的源头，否则在应变纷繁复杂的使用时不知道会发生什么可能的荒谬语意解释.




// __________________________  C标准预定义宏  如何使用 __________________________
#include   <iostream> 
using   namespace   std; 

void   main(void) 
{ 
	cout   <<   __FILE__   		<<   endl;   			//   当前文件路径 
	cout   <<   __LINE__   		<<   endl;   			//   当前文件编译行数 
	cout   <<   __DATE__   		<<   endl;   			//   编译日期 
	cout   <<   __TIME__   		<<   endl;   			//   编译时间 
	cout   <<   __FUNCTION__   	<<   endl; 				//   函数名称
} 

/*
	我们可以在debug的时候输入更多有意义的调试信息
	如下面的：
*/
NSLog(@"%s:%d, %s",__FILE__, __LINE__, __FUNCTION__);     
