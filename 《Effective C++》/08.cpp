
// 条款08：别让异常逃离析构函数  ______  Prevent exceptions from leaving destructors

/*
	C++ 并不禁止 析构函数 吐出异常，但它不鼓励你这样做。
*/


/* 	______________________   ______________________  */
/*
	假设你销毁了一个vecter动态数组，里面每个变量都会执行销毁一次，当第1次销毁时，出现了一次异常。第2个变量销毁时，又出现异常，
	那么接下来会发生什么行为，将是编译器未知的。
*/



/* 	______________________   ______________________  */
/*
	如果你的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？
	比如下面这个例子。
*/
class DBConn
{
public:
	...
	~DBConn()
	{
		db.close();
	}
};

/*
	如果调用 close 成功，一切美好。
	但如果该调用导致异常，DBConn 析构函数 会传播该异常，也就是允许它离开这个析构函数。
*/

// 下面这个网址，对为什么 析构函数里不能抛出异常 解释的还算清楚。
http://www.cnblogs.com/zhyg6516/archive/2011/03/08/1977007.html



/* 	______________________ 用 try 这个方法  ______________________  */
class DBConn
{
public:
	...
	~DBConn()
	{
		try{
			db.close();
		}
		catch{
			// 制作运转记录，记下对 close 的调用失败
			std::abort();		// 异常终止一个进程---强迫结束程序
		}
	}
};
/*
	如此程序 遭遇一个“于析构期间发生的错误”后无法 继续执行，“强迫结束程序” 是个合理选项。
	毕竟它可以阻止 异常从析构函数 传播出去（那会导致不明确的行为）。也就是说调用abort 可以抢先指“不明确行为”于死地。
*/

/* 	______________________  吞掉异常，不强制结束程序  ______________________  */
class DBConn
{
public:
	...
	~DBConn()
	{
		try{
			db.close();
		}
		catch{
			// 制作运转记录，记下对 close 的调用失败
		}
	}
};


/* 	______________________  提供一个普通函数  ______________________  */
class DBConn
{
public:
	void close()		// 提供 客户 使用的新函数
	{
		db.close();
		closed = true;
	}
	...
	~DBConn()
	{
		if(!closed)
		{
			try{
				db.close();
			}
			catch{
				// 制作运转记录，记下对 close 的调用失败
			}
		}
		
	}
};




/* ______________________ 总结	______________________  */
/*
 	01-析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能被抛出异常，析构函数应该铺捉任何异常，然后吞下它们（不传播）或结束程序
 	02-如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数(而非在析构函数中)执行该函数。
*/
