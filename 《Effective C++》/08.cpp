
// 条款08：别让异常逃离析构函数  ______  Prevent exceptions from leaving destructors

/*
	C++ 并不禁止 析构函数 吐出异常，但它不鼓励你这样做。
*/


/* 	______________________   ______________________  */
/*
	假设你销毁了一个vecter动态数组，里面每个变量都会执行销毁一次，当第1次销毁时，出现了一次异常。第2个变量销毁时，又出现异常，
	那么接下来会发生什么行为，将是编译器未知的。
*/



/* 	______________________   ______________________  */
/*
	如果你的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？
	比如下面这个例子。
*/
class DBConn
{
public:
	...
	~DBConn()
	{
		db.close();
	}
};

/*
	如果调用 close 成功，一切美好。
	但如果该调用导致异常，DBConn 析构函数 会传播该异常，也就是允许它离开这个析构函数。
*/

// 下面这个网址，对为什么 析构函数里不能抛出异常 解释的还算清楚。
http://www.cnblogs.com/zhyg6516/archive/2011/03/08/1977007.html



/*
	可以用 try 这个方法。
*/ 

class DBConn
{
public:
	...
	~DBConn()
	{
		if(!closed)
		{
			try{
				db.close();
			}
			catch{
				
			}
		}
		db.close();
	}
};





/* 	______________________   ______________________  */





/* ______________________ 总结	______________________  */
/*
 
*/
