
// 条款22：将成员变量声明为 private  ______  Declare data members private.

/*
	首次带你看看为什么成员变量 不该是 public,然后让你看看所有反对 public 成员变量的论点同样 适用于 protected 成员变量。
	最后，我们将导出一个结论：成员变量 应该是 private。 获得这个结论后，本条款也就大功告成了。
*/

/* 	______________________  从语法一致性  ______________________  */
/*
	如果成员变量 不是 public，客户唯一能够访问对象的办法就是 通过成员函数。
	如果public接口内的每样东西都是函数，客户就不需要在打算访问 class 成员时迷惑地试着记住是否该使用小括号()。
	他们只要做就是了，因为每样东西都是函数。
*/	
classMember->sfs;
classMember->getSfs();

/* 	______________________  精确的控制  ______________________  */
/*
	使用函数可以让你对成员变量的处理有更精确的控制。如果你成员变量为 public,每个人都可以读写它。
	但如果你以函数取得或设定其值，你就可以实现出“不准访问”，“只读访问”，“只写访问”，“读写访问”。

	如此细微地划分访问控制颇有必要，因为许多成员变量 应该被隐藏起来。毕竟每个成员变量都需要一个 get函数和set函数毕竟罕见。
*/


/* 	______________________  封装   ______________________  */
/*
	如果你通过函数访问成员变量，日后可改以某个计算替换这个成员变量，而class客户一点也不会知道 class 的内部实现已经起了变化。

	将成员变量 隐藏 在函数接口的背后，可以为：“所有可能的实现” 提供弹性。
	例如 这可使得成员变量被读或写时轻松通知其他对象，可以验证class的约束条件以及函数的前提和事后状态，可以在多线程环境中执行同步控制......等等。

	封装，意味着你 保留了日后变更实现的权利。
	Public 意味不封装，而几乎可以说，不封装意味不可改变，特别是对被广泛使用的 classes 而言。
*/


/* 	______________________  破坏性假设  ______________________  */
/*
	假设我们有一个 public 成员变量，而我们最终取消了它。
	所有使用它的客户代码都会被破坏，而那是一个不可知的大量。

	假设我们有一个 protected成员变量，而我们最终取消了它。
	所有使用它的 derived classes 都会被破坏，而那也是一个不可知的大量。

	一旦你将一个成员变量 声明为 public 或 protected 而客户开始使用它，就很难改变那个成员变量所涉及的一切。
	太多代码需要重写，重新测试，重新编译。
*/






/* ______________________ 总结	______________________  */
/*
	其实只有两种访问权限：private(提供封装)和其他(不提供封装)。

 	切记将成员变量声明为 private.这可赋予客户访问数据的一致性，可细微划分访问控制，约束条件获得保证，并提供class作者以充分的实现弹性。
 	protected 并不比 public 更具封装性。
*/
