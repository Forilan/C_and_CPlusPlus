

// size_t 类型


// __________________________1  __________________________

size_t 为了增强程序的可移植性，便有了 size_t ，不同系统上，定义size_t 可能不一样。

经测试发现，在32位系统中 size_t 是4字节的，在64位系统中，size_t 是8字节的，这样利用该类型可以增加程序移植性。

size_t 的定义 

它的定义在/usr/include/linux/types.h

                    typedef _kernel_size_t size_t;

 

跟体系结构相关                           

而__kernel_size_t 定义在 /usr/include/asm/posix_types.h                          

安装的是内核的源码

asm-i386/posix_types.h

              typedef unsigned int __kernel_size_t;

asm-1a64/posix_types.h

              typedef unsigned long kernel_size_t;

 

size_t一般用来表示一种计数，比如有多少东西被拷贝等。

例如：sizeof 操作符的结果类型是 size_t ，

memset(strHas, 0, sizeof(strHas));    // memset() 中第3个参数也是 size_t 类型的。


该类型保证能容纳实现所建立的最大对象的字节大小。 
它的意义大致是“适于计量内存中可容纳的数据项目个数的无符号整数类型”。
所以，它在数组下标和内存管理函数之类的地方广泛使用。


// __________________________  __________________________

没什么好说的啊,因为字符长度一般没有负值,索性就定义 
typedef  unsinged int size_t

// __________________________ size_t与size_type有什么区别  __________________________
sizt_t是C++的一个标准的typedef.全局有效，定义在全局名称空间中
size_type是STL定义的，只在namespace std中有效

//为了使自己的程序有很好的移植性，c++程序员应该尽量使用size_t和size_type而不是int,unsigned;

// __________________________  __________________________


在C++中，设计 size_t 就是为了适应多个平台的 。size_t的引入增强了程序在不同平台上的可移植性。
size_t是针对系统定制的一种数据类型，一般是整型，因为C/C++标准只定义一最低的位数，而不是必需的固定位数。
而且在内存里，对数的高位对齐存储还是低位对齐存储各系统都不一样。
为了提高代码的可移植性，就有必要定义这样的数据类型。一般这种类型都会定义到它具体占几位内存等。
当然，有些是编译器或系统已经给定义好的。
经测试发现，在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。




// ~~~~~~~~~~~~~~~~~~~~~~~~~ 说明 ~~~~~~~~~~~~~~~~~~~~~~~~~



